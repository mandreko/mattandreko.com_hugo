<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Protostar on Matt Andreko</title>
    <link>https://www.mattandreko.com/categories/protostar/</link>
    <description>Recent content in Protostar on Matt Andreko</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Sat, 11 Feb 2012 10:11:00 -0500</lastBuildDate>
    
	<atom:link href="https://www.mattandreko.com/categories/protostar/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Exploit Exercises - Protostar Net 3</title>
      <link>https://www.mattandreko.com/2012/02/11/exploit-exercises-protostar-net-3/</link>
      <pubDate>Sat, 11 Feb 2012 10:11:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2012/02/11/exploit-exercises-protostar-net-3/</guid>
      <description>The last in the Net series of Protostar is Net 3. It was of course the most difficult of all of them. However, it still wasn&amp;rsquo;t too bad.
First, we&amp;rsquo;re given the following code:
#include &amp;quot;../common/common.c&amp;quot; #define NAME &amp;quot;net3&amp;quot; #define UID 996 #define GID 996 #define PORT 2996 /* * Extract a null terminated string from the buffer */ int get_string(char **result, unsigned char *buffer, u_int16_t len) { unsigned char byte; byte = *buffer; if(byte &amp;gt; len) errx(1, &amp;quot;badly formed packet&amp;quot;); *result = malloc(byte); strcpy(*result, buffer + 1); return byte + 1; } /* * Check to see if we can log into the host */ int login(unsigned char *buffer, u_int16_t len) { char *resource, *username, *password; int deduct; int success; if(len &amp;lt; 3) errx(1, &amp;quot;invalid login packet length&amp;quot;); resource = username = password = NULL; deduct = get_string(&amp;amp;resource, buffer, len); deduct += get_string(&amp;amp;username, buffer+deduct, len-deduct); deduct += get_string(&amp;amp;password, buffer+deduct, len-deduct); success = 0; success |= strcmp(resource, &amp;quot;net3&amp;quot;); success |= strcmp(username, &amp;quot;awesomesauce&amp;quot;); success |= strcmp(password, &amp;quot;password&amp;quot;); free(resource); free(username); free(password); return !</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Net 2</title>
      <link>https://www.mattandreko.com/2012/02/10/exploit-exercises-protostar-net-2/</link>
      <pubDate>Fri, 10 Feb 2012 05:19:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2012/02/10/exploit-exercises-protostar-net-2/</guid>
      <description>So far, these Net challenges in Protostar have been pretty easy. This challenge, Net 2 got a small bit tougher.
We are given the following code:
#include &amp;quot;../common/common.c&amp;quot; #define NAME &amp;quot;net2&amp;quot; #define UID 997 #define GID 997 #define PORT 2997 void run() { unsigned int quad[4]; int i; unsigned int result, wanted; result = 0; for(i = 0; i &amp;lt; 4; i++) { quad[i] = random(); result += quad[i]; if(write(0, &amp;amp;(quad[i]), sizeof(result)) !</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Net 1</title>
      <link>https://www.mattandreko.com/2012/02/09/exploit-exercises-protostar-net-1/</link>
      <pubDate>Thu, 09 Feb 2012 05:43:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2012/02/09/exploit-exercises-protostar-net-1/</guid>
      <description>Continuing with the &amp;ldquo;Net&amp;rdquo; series of Protostar, is Net 1.
We are given the following code:
#include &amp;quot;../common/common.c&amp;quot; #define NAME &amp;quot;net1&amp;quot; #define UID 998 #define GID 998 #define PORT 2998 void run() { char buf[12]; char fub[12]; char *q; unsigned int wanted; wanted = random(); sprintf(fub, &amp;quot;%d&amp;quot;, wanted); if(write(0, &amp;amp;wanted, sizeof(wanted)) != sizeof(wanted)) { errx(1, &amp;quot;:(\n&amp;quot;); } if(fgets(buf, sizeof(buf)-1, stdin) == NULL) { errx(1, &amp;quot;:(\n&amp;quot;); } q = strchr(buf, &#39;\r&#39;); if(q) *q = 0; q = strchr(buf, &#39;\n&#39;); if(q) *q = 0; if(strcmp(fub, buf) == 0) { printf(&amp;quot;you correctly sent the data\n&amp;quot;); } else { printf(&amp;quot;you didn&#39;t send the data properly\n&amp;quot;); } } int main(int argc, char **argv, char **envp) { int fd; char *username; /* Run the process as a daemon */ background_process(NAME, UID, GID); /* Wait for socket activity and return */ fd = serve_forever(PORT); /* Set the client socket to STDIN, STDOUT, and STDERR */ set_io(fd); /* Don&#39;t do this :&amp;gt; */ srandom(time(NULL)); run(); }  Similar to Net 0, it looks like this is another network daemon, this time running on port 2998.</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Net 0</title>
      <link>https://www.mattandreko.com/2012/02/08/exploit-exercises-protostar-net-0/</link>
      <pubDate>Wed, 08 Feb 2012 18:31:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2012/02/08/exploit-exercises-protostar-net-0/</guid>
      <description>I recently started looking at the &amp;ldquo;Net&amp;rdquo; problems in Protostar, and found them to be quite a fun change in pace.
Starting with Net 0, we are given the following code:
#include &amp;quot;../common/common.c&amp;quot; #define NAME &amp;quot;net0&amp;quot; #define UID 999 #define GID 999 #define PORT 2999 void run() { unsigned int i; unsigned int wanted; wanted = random(); printf(&amp;quot;Please send &#39;%d&#39; as a little endian 32bit int\n&amp;quot;, wanted); if(fread(&amp;amp;i, sizeof(i), 1, stdin) == NULL) { errx(1, &amp;quot;:(\n&amp;quot;); } if(i == wanted) { printf(&amp;quot;Thank you sir/madam\n&amp;quot;); } else { printf(&amp;quot;I&#39;m sorry, you sent %d instead\n&amp;quot;, i); } } int main(int argc, char **argv, char **envp) { int fd; char *username; /* Run the process as a daemon */ background_process(NAME, UID, GID); /* Wait for socket activity and return */ fd = serve_forever(PORT); /* Set the client socket to STDIN, STDOUT, and STDERR */ set_io(fd); /* Don&#39;t do this :&amp;gt; */ srandom(time(NULL)); run(); }  I started to analyze this program, to figure out what I was even supposed to do.</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Final 1</title>
      <link>https://www.mattandreko.com/2012/02/05/exploit-exercises-protostar-final-1/</link>
      <pubDate>Sun, 05 Feb 2012 15:15:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2012/02/05/exploit-exercises-protostar-final-1/</guid>
      <description>Since I&amp;rsquo;ve been doing a lot of the format string exploits lately, I decided to do the Final 1 challenge.
We start out the challenge by being given the following code:
#include &amp;quot;../common/common.c&amp;quot; #include &amp;lt;syslog.h&amp;gt; #define NAME &amp;quot;final1&amp;quot; #define UID 0 #define GID 0 #define PORT 2994 char username[128]; char hostname[64]; void logit(char *pw) { char buf[512]; snprintf(buf, sizeof(buf), &amp;quot;Login from %s as [%s] with password [%s]\n&amp;quot;, hostname, username, pw); syslog(LOG_USER|LOG_DEBUG, buf); } void trim(char *str) { char *q; q = strchr(str, &#39;\r&#39;); if(q) *q = 0; q = strchr(str, &#39;\n&#39;); if(q) *q = 0; } void parser() { char line[128]; printf(&amp;quot;[final1] $ &amp;quot;); while(fgets(line, sizeof(line)-1, stdin)) { trim(line); if(strncmp(line, &amp;quot;username &amp;quot;, 9) == 0) { strcpy(username, line+9); } else if(strncmp(line, &amp;quot;login &amp;quot;, 6) == 0) { if(username[0] == 0) { printf(&amp;quot;invalid protocol\n&amp;quot;); } else { logit(line + 6); printf(&amp;quot;login failed\n&amp;quot;); } } printf(&amp;quot;[final1] $ &amp;quot;); } } void getipport() { int l; struct sockaddr_in sin; l = sizeof(struct sockaddr_in); if(getpeername(0, &amp;amp;sin, &amp;amp;l) == -1) { err(1, &amp;quot;you don&#39;t exist&amp;quot;); } sprintf(hostname, &amp;quot;%s:%d&amp;quot;, inet_ntoa(sin.</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Format 4</title>
      <link>https://www.mattandreko.com/2012/02/02/exploit-exercises-protostar-format-4/</link>
      <pubDate>Thu, 02 Feb 2012 05:15:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2012/02/02/exploit-exercises-protostar-format-4/</guid>
      <description>Next up is the last challenge in the Format String series, Format 4.
It starts out with the following code:
#include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; int target; void hello() { printf(&amp;quot;code execution redirected! you win\n&amp;quot;); _exit(1); } void vuln() { char buffer[512]; fgets(buffer, sizeof(buffer), stdin); printf(buffer); exit(1); } int main(int argc, char **argv) { vuln(); }  What initially caught my eye was the fact that there was a call to &amp;ldquo;exit()&amp;rdquo; as well as &amp;ldquo;_exit()&amp;ldquo;.</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Format 3</title>
      <link>https://www.mattandreko.com/2012/02/01/exploit-exercises-protostar-format-3/</link>
      <pubDate>Wed, 01 Feb 2012 05:33:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2012/02/01/exploit-exercises-protostar-format-3/</guid>
      <description>Continuing in the String Format section, the next challenge we run across is Format 3.
We&amp;rsquo;re first given the following code:
#include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; int target; void printbuffer(char *string) { printf(string); } void vuln() { char buffer[512]; fgets(buffer, sizeof(buffer), stdin); printbuffer(buffer); if(target == 0x01025544) { printf(&amp;quot;you have modified the target :)\n&amp;quot;); } else { printf(&amp;quot;target is %08x :(\n&amp;quot;, target); } } int main(int argc, char **argv) { vuln(); }  This seems to be just like Format 2, except that we have to modify all 8 bytes instead of just 2.</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Format 2</title>
      <link>https://www.mattandreko.com/2012/01/31/exploit-exercises-protostar-format-2/</link>
      <pubDate>Tue, 31 Jan 2012 05:13:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2012/01/31/exploit-exercises-protostar-format-2/</guid>
      <description>Continuing from where we left off, we arrive at Format 2. It presents us with the following code:
#include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; int target; void vuln() { char buffer[512]; fgets(buffer, sizeof(buffer), stdin); printf(buffer); if(target == 64) { printf(&amp;quot;you have modified the target :)\n&amp;quot;); } else { printf(&amp;quot;target is %d :(\n&amp;quot;, target); } } int main(int argc, char **argv) { vuln(); }  This challenge seems very similar to Format 1, in all but 2 ways:</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Format 1</title>
      <link>https://www.mattandreko.com/2012/01/30/exploit-exercises-protostar-format-1/</link>
      <pubDate>Mon, 30 Jan 2012 18:12:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2012/01/30/exploit-exercises-protostar-format-1/</guid>
      <description>Following the Format 0 challenge, I&amp;rsquo;ve had to do a bunch of reading on how format string exploits work on a very low level.
Some resources that I&amp;rsquo;ve found greatly useful:
 Hacking: The Art of Exploitation, 2nd Edition Exploiting Format String Vulnerabilities SecurityTube.net Format String Vulnerabilities Megaprimer  With this challenge, we&amp;rsquo;re given some c code in which we are to find the vulnerability.
#include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;stdio.</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Format 0</title>
      <link>https://www.mattandreko.com/2012/01/24/exploit-exercises-protostar-format-0/</link>
      <pubDate>Tue, 24 Jan 2012 05:13:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2012/01/24/exploit-exercises-protostar-format-0/</guid>
      <description>I&amp;rsquo;ll be honest, I&amp;rsquo;m new to format string exploits. I&amp;rsquo;ve been more experienced with stack overflows, and a little with heap overflows. So hopefully this information is correct, as it&amp;rsquo;s from my current understanding.
Protostar Format 0 starts us off with the following vulnerable code:
#include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; void vuln(char *string) { volatile int target; char buffer[64]; target = 0; sprintf(buffer, string); if(target == 0xdeadbeef) { printf(&amp;quot;you have hit the target correctly :)\n&amp;quot;); } } int main(int argc, char **argv) { vuln(argv[1]); }  Looking at this code, somehow we have to get the variable, &amp;ldquo;target&amp;rdquo;, which is never set anywhere other than to &amp;ldquo;0&amp;rdquo;, to equal &amp;ldquo;0xdeadbeef&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Final 0</title>
      <link>https://www.mattandreko.com/2012/01/22/exploit-exercises-protostar-final-0/</link>
      <pubDate>Sun, 22 Jan 2012 22:08:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2012/01/22/exploit-exercises-protostar-final-0/</guid>
      <description>I for some reason decided to look at the set of &amp;ldquo;final&amp;rdquo; challenges, and found the first one to be not too difficult.
We start with the following code being given to us:
#include &amp;quot;../common/common.c&amp;quot; #define NAME &amp;quot;final0&amp;quot; #define UID 0 #define GID 0 #define PORT 2995 /* * Read the username in from the network */ char *get_username() { char buffer[512]; char *q; int i; memset(buffer, 0, sizeof(buffer)); gets(buffer); /* Strip off trailing new line characters */ q = strchr(buffer, &#39;\n&#39;); if(q) *q = 0; q = strchr(buffer, &#39;\r&#39;); if(q) *q = 0; /* Convert to lower case */ for(i = 0; i &amp;amp;lt; strlen(buffer); i++) { buffer[i] = toupper(buffer[i]); } /* Duplicate the string and return it */ return strdup(buffer); } int main(int argc, char **argv, char **envp) { int fd; char *username; /* Run the process as a daemon */ background_process(NAME, UID, GID); /* Wait for socket activity and return */ fd = serve_forever(PORT); /* Set the client socket to STDIN, STDOUT, and STDERR */ set_io(fd); username = get_username(); printf(&amp;quot;No such user %s\n&amp;quot;, username); }  This is a somewhat standard buffer overflow.</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Heap 1</title>
      <link>https://www.mattandreko.com/2012/01/12/exploit-exercises-protostar-heap-1/</link>
      <pubDate>Thu, 12 Jan 2012 18:28:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2012/01/12/exploit-exercises-protostar-heap-1/</guid>
      <description>This challenge was different for me. The previous heap challenge was easy to pretend it was just a simple stack overflow. This one worked very different, and brought some different challenges with it.
You first start out with the following code:
#include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; struct internet { int priority; char *name; }; void winner() { printf(&amp;quot;and we have a winner @ %d\n&amp;quot;, time(NULL)); } int main(int argc, char **argv) { struct internet *i1, *i2, *i3; i1 = malloc(sizeof(struct internet)); i1-&amp;gt;priority = 1; i1-&amp;gt;name = malloc(8); i2 = malloc(sizeof(struct internet)); i2-&amp;gt;priority = 2; i2-&amp;gt;name = malloc(8); strcpy(i1-&amp;gt;name, argv[1]); strcpy(i2-&amp;gt;name, argv[2]); printf(&amp;quot;and that&#39;s a wrap folks!</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Heap 0</title>
      <link>https://www.mattandreko.com/2012/01/10/exploit-exercises-protostar-heap-0/</link>
      <pubDate>Tue, 10 Jan 2012 05:34:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2012/01/10/exploit-exercises-protostar-heap-0/</guid>
      <description>Now that I&amp;rsquo;ve completed all of the Stack section of protostar, I&amp;rsquo;ve started to move onto Heap. The first of these challenges, is Heap 0.
We are given the following code:
#include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; struct data { char name[64]; }; struct fp { int (*fp)(); }; void winner() { printf(&amp;quot;level passed\n&amp;quot;); } void nowinner() { printf(&amp;quot;level has not been passed\n&amp;quot;); } int main(int argc, char **argv) { struct data *d; struct fp *f; d = malloc(sizeof(struct data)); f = malloc(sizeof(struct fp)); f-&amp;gt;fp = nowinner; printf(&amp;quot;data is at %p, fp is at %p\n&amp;quot;, d, f); strcpy(d-&amp;gt;name, argv[1]); f-&amp;gt;fp(); }  I first needed to find the offset to where I could overwrite the EIP, so I connected to my other machine with the Metasploit Framework installed, and generated a unique string.</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Stack 7</title>
      <link>https://www.mattandreko.com/2012/01/09/exploit-exercises-protostar-stack-7/</link>
      <pubDate>Mon, 09 Jan 2012 18:36:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2012/01/09/exploit-exercises-protostar-stack-7/</guid>
      <description>Welcome everyone to 2012! I took a bit of a break during these holidays, and am just starting to get back going.
This challenge was very interesting to me. I figured it would build off of the previous one. However, it was its own standalone challenge.
We are given the following code to the stack7 executable:
#include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; char *getpath() { char buffer[64]; unsigned int ret; printf(&amp;quot;input path please: &amp;quot;); fflush(stdout); gets(buffer); ret = __builtin_return_address(0); if((ret &amp;amp;amp; 0xb0000000) == 0xb0000000) { printf(&amp;quot;bzzzt (%p)\n&amp;quot;, ret); _exit(1); } printf(&amp;quot;got path %s\n&amp;quot;, buffer); return strdup(buffer); } int main(int argc, char **argv) { getpath(); }  From tinkering with the stack7 executable, I knew I was going to do a stack overflow, and somehow needed to execute code from the stack.</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Stack 6</title>
      <link>https://www.mattandreko.com/2011/12/22/exploit-exercises-protostar-stack-6/</link>
      <pubDate>Thu, 22 Dec 2011 06:02:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2011/12/22/exploit-exercises-protostar-stack-6/</guid>
      <description>The Stack6 challenge was definitely a learning experience for me. This actually went beyond my existing skills, and made me learn some new stuff.
We are given the following code.
#include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; void getpath() { char buffer[64]; unsigned int ret; printf(&amp;quot;input path please: &amp;quot;); fflush(stdout); gets(buffer); ret = __builtin_return_address(0); if((ret &amp;amp; 0xbf000000) == 0xbf000000) { printf(&amp;quot;bzzzt (%p)\n&amp;quot;, ret); _exit(1); } printf(&amp;quot;got path %s\n&amp;quot;, buffer); } int main(int argc, char **argv) { getpath(); }  The first thing I tried to do, was to set it up just like I did on Stack 5.</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Stack 5</title>
      <link>https://www.mattandreko.com/2011/12/17/exploit-exercises-protostar-stack-5/</link>
      <pubDate>Sat, 17 Dec 2011 12:23:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2011/12/17/exploit-exercises-protostar-stack-5/</guid>
      <description>Wow, this challenge was a tough one for me. I ran into some huge problems that I had to work out. Considering this is a &amp;ldquo;standard buffer overflow&amp;rdquo;, I figured it&amp;rsquo;d be as easy as some of the others I&amp;rsquo;ve done in the past. I&amp;rsquo;ll explain my frustrations inline.
First, we&amp;rsquo;re given the following vulnerable program.
#include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; int main(int argc, char **argv) { char buffer[64]; gets(buffer); }  The first task with this challenge was to find the offset of the EIP.</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Stack 4</title>
      <link>https://www.mattandreko.com/2011/12/16/exploit-exercises-protostar-stack-4/</link>
      <pubDate>Fri, 16 Dec 2011 05:52:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2011/12/16/exploit-exercises-protostar-stack-4/</guid>
      <description>With this challenge, I think things really start to get fun, and more real-world.
We are provided with the following C program:
#include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; void win() { printf(&amp;quot;code flow successfully changed\n&amp;quot;); } int main(int argc, char **argv) { char buffer[64]; gets(buffer); }  This C app will simply read a value from user input, and store it in &amp;ldquo;buffer&amp;rdquo;. We then need to get it to somehow execute &amp;ldquo;win()&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Stack 3</title>
      <link>https://www.mattandreko.com/2011/12/15/exploit-exercises-protostar-stack-3/</link>
      <pubDate>Thu, 15 Dec 2011 05:52:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2011/12/15/exploit-exercises-protostar-stack-3/</guid>
      <description>This challenge starts getting a little bit more involved than the previous ones. Instead of just providing a new value for the &amp;ldquo;modified&amp;rdquo; variable, we need to make the code jump to a method, changing the execution.
#include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; void win() { printf(&amp;quot;code flow successfully changed\n&amp;quot;); } int main(int argc, char **argv) { volatile int (*fp)(); char buffer[64]; fp = 0; gets(buffer); if(fp) { printf(&amp;quot;calling function pointer, jumping to 0x%08x\n&amp;quot;, fp); fp(); } }  This means that first of all, we need to find the address of where the &amp;ldquo;win()&amp;rdquo; function is located in the program.</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Stack 2</title>
      <link>https://www.mattandreko.com/2011/12/14/exploit-exercises-protostar-stack-2/</link>
      <pubDate>Wed, 14 Dec 2011 05:08:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2011/12/14/exploit-exercises-protostar-stack-2/</guid>
      <description>This challenge is pretty much the same as the previous challenge, except that the buffer comes from an environmental variable.
#include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; int main(int argc, char **argv) { volatile int modified; char buffer[64]; char *variable; variable = getenv(&amp;quot;GREENIE&amp;quot;); if(variable == NULL) { errx(1, &amp;quot;please set the GREENIE environment variable\n&amp;quot;); } modified = 0; strcpy(buffer, variable); if(modified == 0x0d0a0d0a) { printf(&amp;quot;you have correctly modified the variable\n&amp;quot;); } else { printf(&amp;quot;Try again, you got 0x%08x\n&amp;quot;, modified); } }  This problem can simply be solved by running these commands:</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Stack 1</title>
      <link>https://www.mattandreko.com/2011/12/13/exploit-exercises-protostar-stack-1/</link>
      <pubDate>Tue, 13 Dec 2011 06:12:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2011/12/13/exploit-exercises-protostar-stack-1/</guid>
      <description>This challenge is very similar to the previous one. The main difference is that instead of just validating that the &amp;ldquo;modified&amp;rdquo; value was changed, it validates that it was changed to a specific value, 0x61626364, or &amp;ldquo;dcba&amp;rdquo; in ASCII.
#include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; int main(int argc, char **argv) { volatile int modified; char buffer[64]; if(argc == 1) { errx(1, &amp;quot;please specify an argument\n&amp;quot;); } modified = 0; strcpy(buffer, argv[1]); if(modified == 0x61626364) { printf(&amp;quot;you have correctly got the variable to the right value\n&amp;quot;); } else { printf(&amp;quot;Try again, you got 0x%08x\n&amp;quot;, modified); } }  To complete this, we simply run:</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Stack 0</title>
      <link>https://www.mattandreko.com/2011/12/12/exploit-exercises-protostar-stack-0/</link>
      <pubDate>Mon, 12 Dec 2011 05:17:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2011/12/12/exploit-exercises-protostar-stack-0/</guid>
      <description>I&amp;rsquo;m still working on the Nebula chain of challenges, however, I&amp;rsquo;ve been stuck on Nebula 11 for a bit now, as well as busy outside work.
In the meantime, I still have other challenges that can be solved while I learn how to do more advanced ones. Protostar is another challenge made by Exploit-Exercises, the same people who brought you Nebula.
Protostar Stack 0 is a very easy challenge. After doing a bunch of these challenges, and seeing nobody else doing them, I finally found someone, Mito125.</description>
    </item>
    
  </channel>
</rss>